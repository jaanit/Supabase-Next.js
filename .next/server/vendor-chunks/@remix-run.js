"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@remix-run";
exports.ids = ["vendor-chunks/@remix-run"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@remix-run/router/dist/router.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@remix-run/router/dist/router.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   UNSAFE_DEFERRED_SYMBOL: () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),\n/* harmony export */   UNSAFE_DeferredData: () => (/* binding */ DeferredData),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: () => (/* binding */ convertRouteMatchToUiMatch),\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   UNSAFE_getPathContributingMatches: () => (/* binding */ getPathContributingMatches),\n/* harmony export */   UNSAFE_invariant: () => (/* binding */ invariant),\n/* harmony export */   UNSAFE_warning: () => (/* binding */ warning),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),\n/* harmony export */   defer: () => (/* binding */ defer),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getToPathname: () => (/* binding */ getToPathname),\n/* harmony export */   isDeferredData: () => (/* binding */ isDeferredData),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   joinPaths: () => (/* binding */ joinPaths),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   resolveTo: () => (/* binding */ resolveTo),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename)\n/* harmony export */ });\n/**\n * @remix-run/router v1.9.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */ var Action;\n(function(Action) {\n    /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */ Action[\"Pop\"] = \"POP\";\n    /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map((entry, index)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = Action.Pop;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) {\n            state = null;\n        }\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref,\n        createURL (to) {\n            return new URL(createHref(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = Action.Push;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = Action.Replace;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = Action.Pop;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createBrowserLocation(window1, globalHistory) {\n        let { pathname, search, hash } = window1.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window1, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createHashLocation(window1, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window1.location.hash.substr(1));\n        // Hash URL should always have a leading / just like window.location.pathname\n        // does, so if an app ends up at a route like /#something then we add a\n        // leading slash so all of our path-matching behaves the same as if it would\n        // in a browser router.  This is particularly important when there exists a\n        // root splat route (<Route path=\"*\">) since that matches internally against\n        // \"/*\" and we'd expect /#something to 404 in a hash router app.\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window1, to) {\n        let base = window1.document.querySelector(\"base\");\n        let href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window1.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience, so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message);\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */ function getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */ function createLocation(current, to, state, key) {\n    if (state === void 0) {\n        state = null;\n    }\n    let location = _extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */ function createPath(_ref) {\n    let { pathname = \"/\", search = \"\", hash = \"\" } = _ref;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */ function parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { window: window1 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window1.history;\n    let action = Action.Pop;\n    let listener = null;\n    let index = getIndex();\n    // Index should only be null when we initialize. If not, it's because the\n    // user called history.pushState or history.replaceState directly, in which\n    // case we should log a warning as it will result in bugs.\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState(_extends({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = Action.Pop;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = Action.Push;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            // If the exception is because `state` can't be serialized, let that throw\n            // outwards just like a replace call would so the dev knows the cause\n            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window1.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace(to, state) {\n        action = Action.Replace;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        // window.location.origin is \"null\" (the literal string value) in Firefox\n        // under certain conditions, notably when serving from a local HTML file\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n        let base = window1.location.origin !== \"null\" ? window1.location.origin : window1.location.href;\n        let href = typeof to === \"string\" ? to : createPath(to);\n        invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n        return new URL(href, base);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window1, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window1.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window1.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref(window1, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            // Encode a Location the same way window.location would\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\n//#endregion\nvar ResultType;\n(function(ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    if (manifest === void 0) {\n        manifest = {};\n    }\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        invariant(!manifest[id], 'Found a route id collision on id \"' + id + '\".  Route ' + \"id's must be globally unique within Data Router usages\");\n        if (isIndexRoute(route)) {\n            let indexRoute = _extends({}, route, mapRouteProperties(route), {\n                id\n            });\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n                id,\n                children: undefined\n            });\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */ function matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location\n        // or from router.navigate, but we want to match against the unencoded\n        // paths in the route definitions.  Memory router locations won't be\n        // encoded here but there also shouldn't be anything to decode so this\n        // should be a safe operation.  This avoids needing matchRoutes to be\n        // history-aware.\n        safelyDecodeURI(pathname));\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        // Add the children before adding this route to the array, so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".'));\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        var _route$path;\n        // coarse-grain check for optional params\n        if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */ function explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    // Optional path segments are denoted by a trailing `?`\n    let isOptional = first.endsWith(\"?\");\n    // Compute the corresponding required segment: `foo?` -> `foo`\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        // Intepret empty string as omitting an optional segment\n        // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    // All child paths with the prefix.  Do this for all children before the\n    // optional version for all children, so we get consistent ordering where the\n    // parent optional aspect is preferred as required.  Otherwise, we can get\n    // child sections interspersed where deeper optional segments are higher than\n    // parent optional segments, where for example, /:two would explode _earlier_\n    // then /:one.  By always including the parent as required _for all children_\n    // first, we avoid this issue\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    // Then, if this is an optional value, add all child versions without\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    // for absolute paths, ensure `/` instead of empty segment\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score // Higher score first\n         : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        let route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */ function generatePath(originalPath, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    // ensure `/` is added at the beginning if the path is absolute\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        // only apply the splat if it's the last segment\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            // Apply the splat\n            return stringify(params[star]);\n        }\n        const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n            return stringify(param);\n        }\n        // Remove any optional markers from optional static segments\n        return segment.replace(/\\?$/g, \"\");\n    })// Remove empty segments\n    .filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */ function matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = paramNames.reduce((memo, paramName, index)=>{\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || \"\", paramName);\n        return memo;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    let paramNames = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/\\/:(\\w+)/g, (_, paramName)=>{\n        paramNames.push(paramName);\n        return \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        paramNames.push(\"*\");\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else if (end) {\n        // When matching to the end, ignore trailing slashes\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        // If our path is non-empty and contains anything beyond an initial slash,\n        // then we have _some_ form of path in our regex, so we should expect to\n        // match only if we find the end of this path segment.  Look for an optional\n        // non-captured trailing slash (to match a portion of the URL) or the end\n        // of the path (if we've matched to the end).  We used to do this with a\n        // word boundary but that gives false positives on routes like\n        // /user-preferences since `-` counts as a word boundary.\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else ;\n    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        paramNames\n    ];\n}\nfunction safelyDecodeURI(value) {\n    try {\n        return decodeURI(value);\n    } catch (error) {\n        warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a ' + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n        return value;\n    }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    } catch (error) {\n        warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */ function stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */ function resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */ function getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\n/**\n * @private\n */ function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) {\n        isPathRelative = false;\n    }\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = _extends({}, toArg);\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (isPathRelative || toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        if (toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            // Each leading .. segment means \"go up one route\" instead of \"go up one\n            // URL segment\".  This is a key difference from how <a href> works and a\n            // major reason we call this a \"to\" value instead of a \"href\".\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        // If there are more \"..\" segments than parent routes, resolve relative to\n        // the root / URL.\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    // Ensure the pathname has a trailing slash if the original \"to\" had one\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    // Or if this was a link to the current path which has a trailing slash\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\n/**\n * @private\n */ function getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */ const joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */ const normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */ const normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */ const normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */ const json = function json(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n    return new Response(JSON.stringify(data), _extends({}, responseInit, {\n        headers\n    }));\n};\nclass AbortedDeferredError extends Error {\n}\nclass DeferredData {\n    constructor(data, responseInit){\n        this.pendingKeysSet = new Set();\n        this.subscribers = new Set();\n        this.deferredKeys = [];\n        invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n        // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        let reject;\n        this.abortPromise = new Promise((_, r)=>reject = r);\n        this.controller = new AbortController();\n        let onAbort = ()=>reject(new AbortedDeferredError(\"Deferred data aborted\"));\n        this.unlistenAbortSignal = ()=>this.controller.signal.removeEventListener(\"abort\", onAbort);\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce((acc, _ref)=>{\n            let [key, value] = _ref;\n            return Object.assign(acc, {\n                [key]: this.trackPromise(key, value)\n            });\n        }, {});\n        if (this.done) {\n            // All incoming values were resolved\n            this.unlistenAbortSignal();\n        }\n        this.init = responseInit;\n    }\n    trackPromise(key, value) {\n        if (!(value instanceof Promise)) {\n            return value;\n        }\n        this.deferredKeys.push(key);\n        this.pendingKeysSet.add(key);\n        // We store a little wrapper promise that will be extended with\n        // _data/_error props upon resolve/reject\n        let promise = Promise.race([\n            value,\n            this.abortPromise\n        ]).then((data)=>this.onSettle(promise, key, undefined, data), (error)=>this.onSettle(promise, key, error));\n        // Register rejection listeners to avoid uncaught promise rejections on\n        // errors or aborted deferred values\n        promise.catch(()=>{});\n        Object.defineProperty(promise, \"_tracked\", {\n            get: ()=>true\n        });\n        return promise;\n    }\n    onSettle(promise, key, error, data) {\n        if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n            this.unlistenAbortSignal();\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            return Promise.reject(error);\n        }\n        this.pendingKeysSet.delete(key);\n        if (this.done) {\n            // Nothing left to abort!\n            this.unlistenAbortSignal();\n        }\n        // If the promise was resolved/rejected with undefined, we'll throw an error as you\n        // should always resolve with a value or null\n        if (error === undefined && data === undefined) {\n            let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, ' + \"you must resolve/reject with a value or `null`.\");\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>undefinedError\n            });\n            this.emit(false, key);\n            return Promise.reject(undefinedError);\n        }\n        if (data === undefined) {\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            this.emit(false, key);\n            return Promise.reject(error);\n        }\n        Object.defineProperty(promise, \"_data\", {\n            get: ()=>data\n        });\n        this.emit(false, key);\n        return data;\n    }\n    emit(aborted, settledKey) {\n        this.subscribers.forEach((subscriber)=>subscriber(aborted, settledKey));\n    }\n    subscribe(fn) {\n        this.subscribers.add(fn);\n        return ()=>this.subscribers.delete(fn);\n    }\n    cancel() {\n        this.controller.abort();\n        this.pendingKeysSet.forEach((v, k)=>this.pendingKeysSet.delete(k));\n        this.emit(true);\n    }\n    async resolveData(signal) {\n        let aborted = false;\n        if (!this.done) {\n            let onAbort = ()=>this.cancel();\n            signal.addEventListener(\"abort\", onAbort);\n            aborted = await new Promise((resolve)=>{\n                this.subscribe((aborted)=>{\n                    signal.removeEventListener(\"abort\", onAbort);\n                    if (aborted || this.done) {\n                        resolve(aborted);\n                    }\n                });\n            });\n        }\n        return aborted;\n    }\n    get done() {\n        return this.pendingKeysSet.size === 0;\n    }\n    get unwrappedData() {\n        invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n        return Object.entries(this.data).reduce((acc, _ref2)=>{\n            let [key, value] = _ref2;\n            return Object.assign(acc, {\n                [key]: unwrapTrackedPromise(value)\n            });\n        }, {});\n    }\n    get pendingKeys() {\n        return Array.from(this.pendingKeysSet);\n    }\n}\nfunction isTrackedPromise(value) {\n    return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n    if (!isTrackedPromise(value)) {\n        return value;\n    }\n    if (value._error) {\n        throw value._error;\n    }\n    return value._data;\n}\nconst defer = function defer(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirect = function redirect(url, init) {\n    if (init === void 0) {\n        init = 302;\n    }\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, _extends({}, responseInit, {\n        headers\n    }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */ class ErrorResponseImpl {\n    constructor(status, statusText, data, internal){\n        if (internal === void 0) {\n            internal = false;\n        }\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data instanceof Error) {\n            this.data = data.toString();\n            this.error = data;\n        } else {\n            this.data = data;\n        }\n    }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */ function isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nconst validMutationMethodsArr = [\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\"\n];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\n    \"get\",\n    ...validMutationMethodsArr\n];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nconst redirectPreserveMethodStatusCodes = new Set([\n    307,\n    308\n]);\nconst IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_FETCHER = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: undefined,\n    reset: undefined,\n    location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */ function createRouter(init) {\n    const routerWindow = init.window ? init.window :  false ? 0 : undefined;\n    const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    const isServer = !isBrowser;\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let mapRouteProperties;\n    if (init.mapRouteProperties) {\n        mapRouteProperties = init.mapRouteProperties;\n    } else if (init.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = init.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Routes keyed by ID\n    let manifest = {};\n    // Routes in tree format for matching\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    // Config driven behavior flags\n    let future = _extends({\n        v7_normalizeFormMethod: false,\n        v7_prependBasename: false\n    }, init.future);\n    // Cleanup function for history\n    let unlistenHistory = null;\n    // Externally-provided functions to call on all state changes\n    let subscribers = new Set();\n    // Externally-provided object to hold scroll restoration locations during routing\n    let savedScrollPositions = null;\n    // Externally-provided function to get scroll restoration keys\n    let getScrollRestorationKey = null;\n    // Externally-provided function to get current scroll position\n    let getScrollPosition = null;\n    // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n    // SSR did the initial scroll restoration.\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    }\n    let initialized = // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    !initialMatches.some((m)=>m.route.lazy) && // And we have to either have no loaders or have been provided hydrationData\n    (!initialMatches.some((m)=>m.route.loader) || init.hydrationData != null);\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map(),\n        blockers: new Map()\n    };\n    // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    let pendingAction = Action.Pop;\n    // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    let pendingPreventScrollReset = false;\n    // AbortController for the active navigation\n    let pendingNavigationController;\n    // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    let isUninterruptedRevalidation = false;\n    // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidator()\n    //  - X-Remix-Revalidate (from redirect)\n    let isRevalidationRequired = false;\n    // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    let cancelledDeferredRoutes = [];\n    // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    let cancelledFetcherLoads = [];\n    // AbortControllers for any in-flight fetchers\n    let fetchControllers = new Map();\n    // Track loads based on the order in which they started\n    let incrementingLoadId = 0;\n    // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    let pendingNavigationLoadId = -1;\n    // Fetchers that triggered data reloads as a result of their actions\n    let fetchReloadIds = new Map();\n    // Fetchers that triggered redirect navigations\n    let fetchRedirectIds = new Set();\n    // Most recent href/match for fetcher.load calls for fetchers\n    let fetchLoadMatches = new Map();\n    // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    let activeDeferreds = new Map();\n    // Store blocker functions in a separate Map outside of router state since\n    // we don't need to update UI state if they change\n    let blockerFunctions = new Map();\n    // Flag to ignore the next history update, so we can revert the URL change on\n    // a POP navigation that was blocked by the user without touching router state\n    let ignoreNextHistoryUpdate = false;\n    // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen((_ref)=>{\n            let { action: historyAction, location, delta } = _ref;\n            // Ignore this event if it was just us resetting the URL from a\n            // blocked POP navigation\n            if (ignoreNextHistoryUpdate) {\n                ignoreNextHistoryUpdate = false;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                // Restore the URL to match the current UI, but don't update router state\n                ignoreNextHistoryUpdate = true;\n                init.history.go(delta * -1);\n                // Put the blocker into a blocked state\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: undefined,\n                            reset: undefined,\n                            location\n                        });\n                        // Re-do the same POP navigation we just blocked\n                        init.history.go(delta);\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n        // in the normal navigation flow.  For SSR it's expected that lazy modules are\n        // resolved prior to router creation since we can't go into a fallbackElement\n        // UI for SSR'd apps\n        if (!state.initialized) {\n            startNavigation(Action.Pop, state.location);\n        }\n        return router;\n    }\n    // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    // Update our state and notify the calling context of the change\n    function updateState(newState) {\n        state = _extends({}, state, newState);\n        subscribers.forEach((subscriber)=>subscriber(state));\n    }\n    // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState) {\n        var _location$state, _location$state2;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a mutation submission\n        // - We're past the submitting state and into the loading state\n        // - The location being loaded is not the result of a redirect\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                // Empty actionData -> clear prior actionData due to an action error\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            // Keep the current data if we're wrapping up the action reload\n            actionData = state.actionData;\n        } else {\n            // Clear actionData on any other completed navigations\n            actionData = null;\n        }\n        // Always preserve any existing loaderData from re-used routes\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        // On a successful navigation we can assume we got through all blockers\n        // so we can start fresh\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        // Always respect the user flag.  Otherwise don't reset on mutation\n        // submission navigations unless they redirect\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = undefined;\n        }\n        if (isUninterruptedRevalidation) ;\n        else if (pendingAction === Action.Pop) ;\n        else if (pendingAction === Action.Push) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === Action.Replace) {\n            init.history.replace(location, location.state);\n        }\n        updateState(_extends({}, newState, {\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }));\n        // Reset stateful navigation vars\n        pendingAction = Action.Pop;\n        pendingPreventScrollReset = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    }\n    // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n        // URL from window.location, so we need to encode it here so the behavior\n        // remains the same as POP and non-data-router usages.  new URL() does all\n        // the same encoding we'd get from a history.pushState/window.location read\n        // without having to touch history\n        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n        let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n        let historyAction = Action.Push;\n        if (userReplace === true) {\n            historyAction = Action.Replace;\n        } else if (userReplace === false) ;\n        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            // By default on submissions to the current location we REPLACE so that\n            // users don't have to double-click the back button to get to the prior\n            // location.  If the user redirects to a different location from the\n            // action/loader this will be ignored and the redirect will be a PUSH\n            historyAction = Action.Replace;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            // Put the blocker into a blocked state\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: undefined,\n                        reset: undefined,\n                        location: nextLocation\n                    });\n                    // Send the same navigation through\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        return await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace\n        });\n    }\n    // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") {\n            return;\n        }\n        // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        }\n        // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    }\n    // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    async function startNavigation(historyAction, location, opts) {\n        // Abort any in-progress navigations and start a new one. Unset any ongoing\n        // uninterrupted revalidations unless told otherwise, since we want this\n        // new navigation to update history normally\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        // Save the current scroll position every time we start a new navigation,\n        // and track whether we should reset scroll on completion\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = matchRoutes(routesToUse, location, basename);\n        // Short circuit with a 404 on the root error boundary if we match nothing\n        if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(routesToUse);\n            // Cancel all pending deferred on 404s since we don't keep any routes\n            cancelActiveDeferreds();\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            });\n            return;\n        }\n        // Short circuit if it's only a hash change and not a revalidation or\n        // mutation submission.\n        //\n        // Ignore on initial page loads because since the initial load will always\n        // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n        // which will default to a navigation to /page\n        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            });\n            return;\n        }\n        // Create a controller/Request for this navigation\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let pendingActionData;\n        let pendingError;\n        if (opts && opts.pendingError) {\n            // If we have a pendingError, it means the user attempted a GET submission\n            // with binary FormData so assign here and skip to handleLoaders.  That\n            // way we handle calling loaders above the boundary etc.  It's not really\n            // different from an actionError in that sense.\n            pendingError = {\n                [findNearestBoundary(matches).route.id]: opts.pendingError\n            };\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            // Call action if we received an action submission\n            let actionOutput = await handleAction(request, location, opts.submission, matches, {\n                replace: opts.replace\n            });\n            if (actionOutput.shortCircuited) {\n                return;\n            }\n            pendingActionData = actionOutput.pendingActionData;\n            pendingError = actionOutput.pendingActionError;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            // Create a GET request for the loaders\n            request = new Request(request.url, {\n                signal: request.signal\n            });\n        }\n        // Call loaders\n        let { shortCircuited, loaderData, errors } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);\n        if (shortCircuited) {\n            return;\n        }\n        // Clean up now that the action/loaders have completed.  Don't clean up if\n        // we short circuited because pendingNavigationController will have already\n        // been assigned to a new controller for the next navigation\n        pendingNavigationController = null;\n        completeNavigation(location, _extends({\n            matches\n        }, pendingActionData ? {\n            actionData: pendingActionData\n        } : {}, {\n            loaderData,\n            errors\n        }));\n    }\n    // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    async function handleAction(request, location, submission, matches, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        interruptActiveLoads();\n        // Put us in a submitting state\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        });\n        // Call our action and get the result\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: ResultType.error,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace;\n            if (opts && opts.replace != null) {\n                replace = opts.replace;\n            } else {\n                // If the user didn't explicity indicate replace behavior, replace if\n                // we redirected to the exact same location we're currently at to avoid\n                // double back-buttons\n                replace = result.location === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(state, result, {\n                submission,\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            // By default, all submissions are REPLACE navigations, but if the\n            // action threw an error that'll be rendered in an errorElement, we fall\n            // back to PUSH so that the user can use the back button to get back to\n            // the pre-submission form location to try again\n            if ((opts && opts.replace) !== true) {\n                pendingAction = Action.Push;\n            }\n            return {\n                // Send back an empty object we can use to clear out any prior actionData\n                pendingActionData: {},\n                pendingActionError: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            };\n        }\n        if (isDeferredResult(result)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        return {\n            pendingActionData: {\n                [actionMatch.route.id]: result.data\n            }\n        };\n    }\n    // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {\n        // Figure out the right navigation we want to use for data loading\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        // If this was a redirect from an action we don't have a \"submission\" but\n        // we have it on the loading navigation so use that if available\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n        // Cancel pending deferreds for no-longer-matched routes or routes we're\n        // about to reload.  Note that if this is an action reload we would have\n        // already cancelled all pending deferreds so this would be a no-op\n        cancelActiveDeferreds((routeId)=>!(matches && matches.some((m)=>m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m)=>m.route.id === routeId));\n        pendingNavigationLoadId = ++incrementingLoadId;\n        // Short circuit if we have no loaders to run\n        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n            let updatedFetchers = markFetchRedirectsDone();\n            completeNavigation(location, _extends({\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingError || null\n            }, pendingActionData ? {\n                actionData: pendingActionData\n            } : {}, updatedFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}));\n            return {\n                shortCircuited: true\n            };\n        }\n        // If this is an uninterrupted revalidation, we remain in our current idle\n        // state.  If not, we need to switch to our loading state and load data,\n        // preserving any new action data or existing action data (in the case of\n        // a revalidation interrupting an actionReload)\n        if (!isUninterruptedRevalidation) {\n            revalidatingFetchers.forEach((rf)=>{\n                let fetcher = state.fetchers.get(rf.key);\n                let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                state.fetchers.set(rf.key, revalidatingFetcher);\n            });\n            let actionData = pendingActionData || state.actionData;\n            updateState(_extends({\n                navigation: loadingNavigation\n            }, actionData ? Object.keys(actionData).length === 0 ? {\n                actionData: null\n            } : {\n                actionData\n            } : {}, revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}));\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            if (fetchControllers.has(rf.key)) {\n                abortFetcher(rf.key);\n            }\n            if (rf.controller) {\n                // Fetchers use an independent AbortController so that aborting a fetcher\n                // (via deleteFetcher) does not abort the triggering navigation that\n                // triggered the revalidation\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        // Proxy navigation abort through to revalidation fetchers\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        // Clean up _after_ loaders have completed.  Don't clean up if we short\n        // circuited because fetchControllers would have been aborted and\n        // reassigned to new controllers for the next navigation\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        // If any loaders returned a redirect Response, start a new REPLACE navigation\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            await startRedirectNavigation(state, redirect.result, {\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Wire up subscribers to update loaderData as promises settle\n        activeDeferreds.forEach((deferredData, routeId)=>{\n            deferredData.subscribe((aborted)=>{\n                // Note: No need to updateState here since the TrackedPromise on\n                // loaderData is stable across resolve/reject\n                // Remove this instance if we were aborted or if promises have settled\n                if (aborted || deferredData.done) {\n                    activeDeferreds.delete(routeId);\n                }\n            });\n        });\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return _extends({\n            loaderData,\n            errors\n        }, shouldUpdateFetchers ? {\n            fetchers: new Map(state.fetchers)\n        } : {});\n    }\n    function getFetcher(key) {\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (isServer) {\n            throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n        }\n        if (fetchControllers.has(key)) abortFetcher(key);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }));\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error);\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            handleFetcherAction(key, routeId, path, match, matches, submission);\n            return;\n        }\n        // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        handleFetcherLoader(key, routeId, path, match, matches, submission);\n    }\n    // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        if (!match.route.action && !match.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: submission.formMethod,\n                pathname: path,\n                routeId: routeId\n            });\n            setFetcherError(key, routeId, error);\n            return;\n        }\n        // Put this fetcher into it's submitting state\n        let existingFetcher = state.fetchers.get(key);\n        let fetcher = getSubmittingFetcher(submission, existingFetcher);\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        // Call the action for the fetcher\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n        if (fetchRequest.signal.aborted) {\n            // We can delete this so long as we weren't aborted by ou our own fetcher\n            // re-submit which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        if (isRedirectResult(actionResult)) {\n            fetchControllers.delete(key);\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our action started, so that\n                // should take precedence over this redirect navigation.  We already\n                // set isRevalidationRequired so all loaders for the new route should\n                // fire unless opted out via shouldRevalidate\n                let doneFetcher = getDoneFetcher(undefined);\n                state.fetchers.set(key, doneFetcher);\n                updateState({\n                    fetchers: new Map(state.fetchers)\n                });\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                let loadingFetcher = getLoadingFetcher(submission);\n                state.fetchers.set(key, loadingFetcher);\n                updateState({\n                    fetchers: new Map(state.fetchers)\n                });\n                return startRedirectNavigation(state, actionResult, {\n                    fetcherSubmission: submission\n                });\n            }\n        }\n        // Process any non-redirect errors thrown\n        if (isErrorResult(actionResult)) {\n            setFetcherError(key, routeId, actionResult.error);\n            return;\n        }\n        if (isDeferredResult(actionResult)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        // Start the data load for current matches, or the next location if we're\n        // in the middle of a navigation\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n            [match.route.id]: actionResult.data\n        }, undefined // No need to send through errors since we short circuit above\n        );\n        // Put all revalidating fetchers into the loading state, except for the\n        // current fetcher which we want to keep in it's current loading state which\n        // contains it's action submission info + action data\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            if (fetchControllers.has(staleKey)) {\n                abortFetcher(staleKey);\n            }\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            return startRedirectNavigation(state, redirect.result);\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Since we let revalidations complete even if the submitting fetcher was\n        // deleted, only put it back to idle if it hasn't been deleted\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n        // If we are currently in a navigation loading state and this fetcher is\n        // more recent than the navigation, we want the newer data so abort the\n        // navigation and complete it with the fetcher data\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            // otherwise just update with the fetcher data, preserving any existing\n            // loaderData for loaders that did not need to reload.  We have to\n            // manually merge here since we aren't going through completeNavigation\n            updateState(_extends({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)\n            }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}));\n            isRevalidationRequired = false;\n        }\n    }\n    // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    async function handleFetcherLoader(key, routeId, path, match, matches, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        // Put this fetcher into it's loading state\n        let loadingFetcher = getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined);\n        state.fetchers.set(key, loadingFetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        // Call the loader for this fetcher route match\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n        // Deferred isn't supported for fetcher loads, await everything and treat it\n        // as a normal load.  resolveDeferredData will return undefined if this\n        // fetcher gets aborted, so we just leave result untouched and short circuit\n        // below if that happens\n        if (isDeferredResult(result)) {\n            result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n        }\n        // We can delete this so long as we weren't aborted by our our own fetcher\n        // re-load which would have put _new_ controller is in fetchControllers\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        // If the loader threw a redirect Response, start a new REPLACE navigation\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our loader started, so that\n                // should take precedence over this redirect navigation\n                let doneFetcher = getDoneFetcher(undefined);\n                state.fetchers.set(key, doneFetcher);\n                updateState({\n                    fetchers: new Map(state.fetchers)\n                });\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(state, result);\n                return;\n            }\n        }\n        // Process any non-redirect errors thrown\n        if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, routeId);\n            state.fetchers.delete(key);\n            // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n            // do we need to behave any differently with our non-redirect errors?\n            // What if it was a non-redirect Response?\n            updateState({\n                fetchers: new Map(state.fetchers),\n                errors: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            });\n            return;\n        }\n        invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n        // Put the fetcher back into an idle state\n        let doneFetcher = getDoneFetcher(result.data);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */ async function startRedirectNavigation(state, redirect, _temp) {\n        let { submission, fetcherSubmission, replace } = _temp === void 0 ? {} : _temp;\n        if (redirect.revalidate) {\n            isRevalidationRequired = true;\n        }\n        let redirectLocation = createLocation(state.location, redirect.location, {\n            _isRedirect: true\n        });\n        invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n        if (isBrowser) {\n            let isDocumentReload = false;\n            if (redirect.reloadDocument) {\n                // Hard reload if the response contained X-Remix-Reload-Document\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n                const url = init.history.createURL(redirect.location);\n                isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n                url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace) {\n                    routerWindow.location.replace(redirect.location);\n                } else {\n                    routerWindow.location.assign(redirect.location);\n                }\n                return;\n            }\n        }\n        // There's no need to abort on redirects, since we don't detect the\n        // redirect until the action/loaders have settled\n        pendingNavigationController = null;\n        let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n        // Use the incoming submission if provided, fallback on the active one in\n        // state.navigation\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        // If this was a 307/308 submission we want to preserve the HTTP method and\n        // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n        // redirected location\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                submission: _extends({}, activeSubmission, {\n                    formAction: redirect.location\n                }),\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        } else {\n            // If we have a navigation submission, we will preserve it through the\n            // redirect navigation\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        }\n    }\n    async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n        // Call all navigation loaders and revalidating fetcher loaders in parallel,\n        // then slice off the results into separate arrays so we can handle them\n        // accordingly\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename)),\n            ...fetchersToLoad.map((f)=>{\n                if (f.matches && f.match && f.controller) {\n                    return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n                } else {\n                    let error = {\n                        type: ResultType.error,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    };\n                    return error;\n                }\n            })\n        ]);\n        let loaderResults = results.slice(0, matchesToLoad.length);\n        let fetcherResults = results.slice(matchesToLoad.length);\n        await Promise.all([\n            resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(()=>request.signal), false, state.loaderData),\n            resolveDeferredResults(currentMatches, fetchersToLoad.map((f)=>f.match), fetcherResults, fetchersToLoad.map((f)=>f.controller ? f.controller.signal : null), true)\n        ]);\n        return {\n            results,\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true;\n        // Cancel pending route-level deferreds and mark cancelled routes for\n        // revalidation\n        cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n        // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function setFetcherError(key, routeId, error) {\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        // Don't abort the controller if this is a deletion of a fetcher.submit()\n        // in it's loading phase since - we don't want to abort the corresponding\n        // revalidation and want them to complete and land\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        state.fetchers.delete(key);\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        invariant(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, \"Expected fetcher: \" + key);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    // Utility function to update blockers, ensuring valid state transitions\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        // Poor mans state machine :)\n        // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation(_ref2) {\n        let { currentLocation, nextLocation, historyAction } = _ref2;\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        // We ony support a single active blocker at the moment since we don't have\n        // any compelling use cases for multi-blocker yet\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            // If the blocker is currently proceeding, we don't need to re-check\n            // it and can let this navigation continue\n            return;\n        }\n        // At this point, we know we're unblocked/blocked so we need to check the\n        // user-provided blocker function\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function cancelActiveDeferreds(predicate) {\n        let cancelledRouteIds = [];\n        activeDeferreds.forEach((dfd, routeId)=>{\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    }\n    // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || null;\n        // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey) {\n            let key = getScrollRestorationKey(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties;\n    if (opts != null && opts.mapRouteProperties) {\n        mapRouteProperties = opts.mapRouteProperties;\n    } else if (opts != null && opts.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = opts.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n    /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */ async function query(request, _temp2) {\n        let { requestContext } = _temp2 === void 0 ? {} : _temp2;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let result = await queryImpl(request, location, matches, requestContext);\n        if (isResponse(result)) {\n            return result;\n        }\n        // When returning StaticHandlerContext, we patch back in the location here\n        // since we need it for React Context.  But this helps keep our submit and\n        // loadRouteData operating on a Request instead of a Location\n        return _extends({\n            location,\n            basename\n        }, result);\n    }\n    /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */ async function queryRoute(request, _temp3) {\n        let { routeId, requestContext } = _temp3 === void 0 ? {} : _temp3;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            // This should never hit I don't think?\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let result = await queryImpl(request, location, matches, requestContext, match);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : undefined;\n        if (error !== undefined) {\n            // If we got back result.errors, that means the loader/action threw\n            // _something_ that wasn't a Response, but it's not guaranteed/required\n            // to be an `instanceof Error` either, so we have to use throw here to\n            // preserve the \"error\" state outside of queryImpl.\n            throw error;\n        }\n        // Pick off the right state value to return\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            var _result$activeDeferre;\n            let data = Object.values(result.loaderData)[0];\n            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n                data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n            }\n            return data;\n        }\n        return undefined;\n    }\n    async function queryImpl(request, location, matches, requestContext, routeMatch) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method.toLowerCase())) {\n                let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n                return result;\n            }\n            let result = await loadRouteData(request, matches, requestContext, routeMatch);\n            return isResponse(result) ? result : _extends({}, result, {\n                actionData: null,\n                actionHeaders: {}\n            });\n        } catch (e) {\n            // If the user threw/returned a Response in callLoaderOrAction, we throw\n            // it to bail out and then return or throw here based on whether the user\n            // returned or threw\n            if (isQueryRouteResponse(e)) {\n                if (e.type === ResultType.error) {\n                    throw e.response;\n                }\n                return e.response;\n            }\n            // Redirects are always returned since they don't propagate to catch\n            // boundaries\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n                isStaticRequest: true,\n                isRouteRequest,\n                requestContext\n            });\n            if (request.signal.aborted) {\n                let method = isRouteRequest ? \"queryRoute\" : \"query\";\n                throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n            }\n        }\n        if (isRedirectResult(result)) {\n            // Uhhhh - this should never happen, we should always throw these from\n            // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n            // can get back on the \"throw all redirect responses\" train here should\n            // this ever happen :/\n            throw new Response(null, {\n                status: result.status,\n                headers: {\n                    Location: result.location\n                }\n            });\n        }\n        if (isDeferredResult(result)) {\n            let error = getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        }\n        if (isRouteRequest) {\n            // Note: This should only be non-Response values if we get here, since\n            // isRouteRequest should throw any Response received in callLoaderOrAction\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            let context = await loadRouteData(request, matches, requestContext, undefined, {\n                [boundaryMatch.route.id]: result.error\n            });\n            // action status codes take precedence over loader status codes\n            return _extends({}, context, {\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n                actionData: null,\n                actionHeaders: _extends({}, result.headers ? {\n                    [actionMatch.route.id]: result.headers\n                } : {})\n            });\n        }\n        // Create a GET request for the loaders\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        let context = await loadRouteData(loaderRequest, matches, requestContext);\n        return _extends({}, context, result.statusCode ? {\n            statusCode: result.statusCode\n        } : {}, {\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            actionHeaders: _extends({}, result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {})\n        });\n    }\n    async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n        let isRouteRequest = routeMatch != null;\n        // Short circuit if we have no loaders to run (queryRoute())\n        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch == null ? void 0 : routeMatch.route.id\n            });\n        }\n        let requestMatches = routeMatch ? [\n            routeMatch\n        ] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n        let matchesToLoad = requestMatches.filter((m)=>m.route.loader || m.route.lazy);\n        // Short circuit if we have no loaders to run (query())\n        if (matchesToLoad.length === 0) {\n            return {\n                matches,\n                // Add a null for all matched routes for proper revalidation on the client\n                loaderData: matches.reduce((acc, m)=>Object.assign(acc, {\n                        [m.route.id]: null\n                    }), {}),\n                errors: pendingActionError || null,\n                statusCode: 200,\n                loaderHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, {\n                    isStaticRequest: true,\n                    isRouteRequest,\n                    requestContext\n                }))\n        ]);\n        if (request.signal.aborted) {\n            let method = isRouteRequest ? \"queryRoute\" : \"query\";\n            throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n        }\n        // Process and commit output from loaders\n        let activeDeferreds = new Map();\n        let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n        // Add a null for any non-loader matches for proper revalidation on the client\n        let executedLoaders = new Set(matchesToLoad.map((match)=>match.route.id));\n        matches.forEach((match)=>{\n            if (!executedLoaders.has(match.route.id)) {\n                context.loaderData[match.route.id] = null;\n            }\n        });\n        return _extends({}, context, {\n            matches,\n            activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n        });\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */ function getStaticContextFromError(routes, context, error) {\n    let newContext = _extends({}, context, {\n        statusCode: 500,\n        errors: {\n            [context._deepestRenderedBoundaryId || routes[0].id]: error\n        }\n    });\n    return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId != null && relative !== \"path\") {\n        // Grab matches up to the calling route so our route-relative logic is\n        // relative to the correct source route.  When using relative:path,\n        // fromRouteId is ignored since that is always relative to the current\n        // location path\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    // Resolve the relative path\n    let path = resolveTo(to ? to : \".\", getPathContributingMatches(contextualMatches).map((m)=>m.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    // When `to` is not specified we inherit search/hash from the current\n    // location, unlike when to=\".\" and we just inherit the path.\n    // See https://github.com/remix-run/remix/issues/927\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    // Add an ?index param for matched index routes if we don't already have one\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname.  If\n    // this is a root navigation, then just use the raw basename which allows\n    // the basename to have full control over the presence of a trailing slash\n    // on root actions\n    if (prependBasename && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n    // Return location verbatim on non-submission navigations\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    // Create a Submission on non-GET navigations\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== undefined) {\n        if (opts.formEncType === \"text/plain\") {\n            // text only support POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, _ref3)=>{\n                let [name, value] = _ref3;\n                return \"\" + acc + name + \"=\" + value + \"\\n\";\n            }, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: undefined,\n                    json: undefined,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            // json only supports POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: undefined,\n                        json,\n                        text: undefined\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: undefined,\n        text: undefined\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    // Flatten submission onto URLSearchParams for GET submissions\n    let parsedPath = parsePath(path);\n    // On GET navigation submissions we can drop the ?index param from the\n    // resulting location since all loaders will run.  But fetcher GET submissions\n    // only run a single loader so we need to preserve any incoming ?index params\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = \"?\" + searchParams;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    let boundaryMatches = matches;\n    if (boundaryId) {\n        let index = matches.findIndex((m)=>m.route.id === boundaryId);\n        if (index >= 0) {\n            boundaryMatches = matches.slice(0, index);\n        }\n    }\n    return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n    let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    // Pick navigation matches that are net-new or qualify for revalidation\n    let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n    let navigationMatches = boundaryMatches.filter((match, index)=>{\n        if (match.route.lazy) {\n            // We haven't loaded this route yet so we don't know if it's got a loader!\n            return true;\n        }\n        if (match.route.loader == null) {\n            return false;\n        }\n        // Always call the loader on new route instances and pending defer cancellations\n        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id)=>id === match.route.id)) {\n            return true;\n        }\n        // This is the default implementation for when we revalidate.  If the route\n        // provides it's own implementation, then we give them full control but\n        // provide this value so they can leverage it if needed after they check\n        // their own specific use cases\n        let currentRouteMatch = state.matches[index];\n        let nextRouteMatch = match;\n        return shouldRevalidateLoader(match, _extends({\n            currentUrl,\n            currentParams: currentRouteMatch.params,\n            nextUrl,\n            nextParams: nextRouteMatch.params\n        }, submission, {\n            actionResult,\n            defaultShouldRevalidate: // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n            isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n        }));\n    });\n    // Pick fetcher.loads that need to be revalidated\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        // Don't revalidate if fetcher won't be present in the subsequent render\n        if (!matches.some((m)=>m.route.id === f.routeId)) {\n            return;\n        }\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        // If the fetcher path no longer matches, push it in with null matches so\n        // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n        // currently only a use-case for Remix HMR where the route tree can change\n        // at runtime and remove a route previously loaded via a fetcher\n        if (!fetcherMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                controller: null\n            });\n            return;\n        }\n        // Revalidating fetchers are decoupled from the route matches since they\n        // load from a static href.  They revalidate based on explicit revalidation\n        // (submission, useRevalidator, or X-Remix-Revalidate)\n        let fetcher = state.fetchers.get(key);\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let shouldRevalidate = false;\n        if (fetchRedirectIds.has(key)) {\n            // Never trigger a revalidation of an actively redirecting fetcher\n            shouldRevalidate = false;\n        } else if (cancelledFetcherLoads.includes(key)) {\n            // Always revalidate if the fetcher was cancelled\n            shouldRevalidate = true;\n        } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n            // If the fetcher hasn't ever completed loading yet, then this isn't a\n            // revalidation, it would just be a brand new load if an explicit\n            // revalidation is required\n            shouldRevalidate = isRevalidationRequired;\n        } else {\n            // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n            // to explicit revalidations only\n            shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n                currentUrl,\n                currentParams: state.matches[state.matches.length - 1].params,\n                nextUrl,\n                nextParams: matches[matches.length - 1].params\n            }, submission, {\n                actionResult,\n                defaultShouldRevalidate: isRevalidationRequired\n            }));\n        }\n        if (shouldRevalidate) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherMatches,\n                match: fetcherMatch,\n                controller: new AbortController()\n            });\n        }\n    });\n    return [\n        navigationMatches,\n        revalidatingFetchers\n    ];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    let isMissingData = currentLoaderData[match.route.id] === undefined;\n    // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */ async function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n    if (!route.lazy) {\n        return;\n    }\n    let lazyRoute = await route.lazy();\n    // If the lazy route function was executed and removed by another parallel\n    // call then we can return - first lazy() to finish wins because the return\n    // value of lazy is expected to be static\n    if (!route.lazy) {\n        return;\n    }\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    // Update the route in place.  This should be safe because there's no way\n    // we could yet be sitting on this route as we can't get there without\n    // resolving lazy() first.\n    //\n    // This is different than the HMR \"update\" use-case where we may actively be\n    // on the route being updated.  The main concern boils down to \"does this\n    // mutation affect any ongoing navigations or any current state.matches\n    // values?\".  If not, it should be safe to update in place.\n    let routeUpdates = {};\n    for(let lazyRouteProperty in lazyRoute){\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isPropertyStaticallyDefined = staticRouteValue !== undefined && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" ' + \"defined but its lazy function is also returning a value for this property. \" + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n            routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n        }\n    }\n    // Mutate the route with the provided updates.  Do this first so we pass\n    // the updated version to mapRouteProperties\n    Object.assign(routeToUpdate, routeUpdates);\n    // Mutate the `hasErrorBoundary` property on the route based on the route\n    // updates and remove the `lazy` function so we don't resolve the lazy\n    // route again.\n    Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n        lazy: undefined\n    }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let resultType;\n    let result;\n    let onReject;\n    let runHandler = (handler)=>{\n        // Setup a promise we can race against so that abort signals short circuit\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        return Promise.race([\n            handler({\n                request,\n                params: match.params,\n                context: opts.requestContext\n            }),\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = match.route[type];\n        if (match.route.lazy) {\n            if (handler) {\n                // Run statically defined handler in parallel with lazy()\n                let handlerError;\n                let values = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    loadLazyRouteModule(match.route, mapRouteProperties, manifest)\n                ]);\n                if (handlerError) {\n                    throw handlerError;\n                }\n                result = values[0];\n            } else {\n                // Load lazy route module, then run any returned handler\n                await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n                handler = match.route[type];\n                if (handler) {\n                    // Handler still run even if we got interrupted to maintain consistency\n                    // with un-abortable behavior of handler execution on non-lazy or\n                    // previously-lazy-loaded routes\n                    result = await runHandler(handler);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    // lazy() route has no loader to run.  Short circuit here so we don't\n                    // hit the invariant below that errors on returning undefined.\n                    return {\n                        type: ResultType.data,\n                        data: undefined\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n        invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n    } catch (e) {\n        resultType = ResultType.error;\n        result = e;\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    if (isResponse(result)) {\n        let status = result.status;\n        // Process redirects\n        if (redirectStatusCodes.has(status)) {\n            let location = result.headers.get(\"Location\");\n            invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n            // Support relative routing in internal redirects\n            if (!ABSOLUTE_URL_REGEX.test(location)) {\n                location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n            } else if (!opts.isStaticRequest) {\n                // Strip off the protocol+origin for same-origin + same-basename absolute\n                // redirects. If this is a static request, we can let it go back to the\n                // browser as-is\n                let currentUrl = new URL(request.url);\n                let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n                let isSameBasename = stripBasename(url.pathname, basename) != null;\n                if (url.origin === currentUrl.origin && isSameBasename) {\n                    location = url.pathname + url.search + url.hash;\n                }\n            }\n            // Don't process redirects in the router during static requests requests.\n            // Instead, throw the Response and let the server handle it with an HTTP\n            // redirect.  We also update the Location header in place in this flow so\n            // basename and relative routing is taken into account\n            if (opts.isStaticRequest) {\n                result.headers.set(\"Location\", location);\n                throw result;\n            }\n            return {\n                type: ResultType.redirect,\n                status,\n                location,\n                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n                reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n            };\n        }\n        // For SSR single-route requests, we want to hand Responses back directly\n        // without unwrapping.  We do this with the QueryRouteResponse wrapper\n        // interface so we can know whether it was returned or thrown\n        if (opts.isRouteRequest) {\n            let queryRouteResponse = {\n                type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n                response: result\n            };\n            throw queryRouteResponse;\n        }\n        let data;\n        let contentType = result.headers.get(\"Content-Type\");\n        // Check between word boundaries instead of startsWith() due to the last\n        // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n        if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n            data = await result.json();\n        } else {\n            data = await result.text();\n        }\n        if (resultType === ResultType.error) {\n            return {\n                type: resultType,\n                error: new ErrorResponseImpl(status, result.statusText, data),\n                headers: result.headers\n            };\n        }\n        return {\n            type: ResultType.data,\n            data,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (resultType === ResultType.error) {\n        return {\n            type: resultType,\n            error: result\n        };\n    }\n    if (isDeferredData(result)) {\n        var _result$init, _result$init2;\n        return {\n            type: ResultType.deferred,\n            deferredData: result,\n            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n            headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n        };\n    }\n    return {\n        type: ResultType.data,\n        data: result\n    };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        // Didn't think we needed this but it turns out unlike other methods, patch\n        // won't be properly normalized to uppercase and results in a 405 error.\n        // See: https://fetch.spec.whatwg.org/#concept-method\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    // Process loader results into state.loaderData/state.errors\n    results.forEach((result, index)=>{\n        let id = matchesToLoad[index].route.id;\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            let boundaryMatch = findNearestBoundary(matches, id);\n            let error = result.error;\n            // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = errors || {};\n            // Prefer higher error values if lower errors bubble to the same boundary\n            if (errors[boundaryMatch.route.id] == null) {\n                errors[boundaryMatch.route.id] = error;\n            }\n            // Clear our any prior loaderData for the throwing route\n            loaderData[id] = undefined;\n            // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            if (isDeferredResult(result)) {\n                activeDeferreds.set(id, result.deferredData);\n                loaderData[id] = result.deferredData.data;\n            } else {\n                loaderData[id] = result.data;\n            }\n            // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here.  Also clear out any loaderData for the\n    // throwing route\n    if (pendingError) {\n        errors = pendingError;\n        loaderData[Object.keys(pendingError)[0]] = undefined;\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    let { loaderData, errors } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n    // Process results from our revalidating fetchers\n    for(let index = 0; index < revalidatingFetchers.length; index++){\n        let { key, match, controller } = revalidatingFetchers[index];\n        invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        let result = fetcherResults[index];\n        // Process fetcher non-redirect errors\n        if (controller && controller.signal.aborted) {\n            continue;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = _extends({}, errors, {\n                    [boundaryMatch.route.id]: result.error\n                });\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            // Should never get here, redirects should get processed above, but we\n            // keep this to type narrow to a success result in the else\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else if (isDeferredResult(result)) {\n            // Should never get here, deferred data should be awaited for fetchers\n            // in resolveDeferredResults\n            invariant(false, \"Unhandled fetcher deferred data\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = _extends({}, newLoaderData);\n    for (let match of matches){\n        let id = match.route.id;\n        if (newLoaderData.hasOwnProperty(id)) {\n            if (newLoaderData[id] !== undefined) {\n                mergedLoaderData[id] = newLoaderData[id];\n            }\n        } else if (loaderData[id] !== undefined && match.route.loader) {\n            // Preserve existing keys not included in newLoaderData and where a loader\n            // wasn't removed by HMR\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    let route = routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: \"__shim-error-route__\"\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, _temp4) {\n    let { pathname, routeId, method, type } = _temp4 === void 0 ? {} : _temp4;\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (type === \"defer-action\") {\n            errorMessage = \"defer() is not supported in actions\";\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = 'No route matches URL \"' + pathname + '\"';\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (method) {\n            errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n    for(let i = results.length - 1; i >= 0; i--){\n        let result = results[i];\n        if (isRedirectResult(result)) {\n            return {\n                result,\n                idx: i\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath(_extends({}, parsedPath, {\n        hash: \"\"\n    }));\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        // /page -> /page#hash\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        // /page#hash -> /page#hash\n        return true;\n    } else if (b.hash !== \"\") {\n        // /page#hash -> /page#other\n        return true;\n    }\n    // If the hash is removed the browser will re-perform a request to the server\n    // /page#hash -> /page\n    return false;\n}\nfunction isDeferredResult(result) {\n    return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n    return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n    let deferred = value;\n    return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n    if (!isResponse(result)) {\n        return false;\n    }\n    let status = result.status;\n    let location = result.headers.get(\"Location\");\n    return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n    return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    for(let index = 0; index < results.length; index++){\n        let result = results[index];\n        let match = matchesToLoad[index];\n        // If we don't have a match, then we can have a deferred result to do\n        // anything with.  This is for revalidating fetchers where the route was\n        // removed during HMR\n        if (!match) {\n            continue;\n        }\n        let currentMatch = currentMatches.find((m)=>m.route.id === match.route.id);\n        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n            // Note: we do not have to touch activeDeferreds here since we race them\n            // against the signal in resolveDeferredData and they'll get aborted\n            // there if needed\n            let signal = signals[index];\n            invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n            await resolveDeferredData(result, signal, isFetcher).then((result)=>{\n                if (result) {\n                    results[index] = result || results[index];\n                }\n            });\n        }\n    }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n    if (unwrap === void 0) {\n        unwrap = false;\n    }\n    let aborted = await result.deferredData.resolveData(signal);\n    if (aborted) {\n        return;\n    }\n    if (unwrap) {\n        try {\n            return {\n                type: ResultType.data,\n                data: result.deferredData.unwrappedData\n            };\n        } catch (e) {\n            // Handle any TrackedPromise._error values encountered while unwrapping\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n    }\n    return {\n        type: ResultType.data,\n        data: result.deferredData.data\n    };\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        // Return the leaf index route when index is present\n        return matches[matches.length - 1];\n    }\n    // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n    // pathless layout routes)\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json: undefined,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: undefined,\n            text: undefined\n        };\n    } else if (json !== undefined) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined,\n            data\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : undefined\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        json: undefined,\n        text: undefined,\n        data\n    };\n    return fetcher;\n}\n//#endregion\n //# sourceMappingURL=router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcm91dGVyL2Rpc3Qvcm91dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNBO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUN6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxnRkFBZ0Y7QUFDaEYsNkJBQTZCO0FBQzdCLGdGQUFnRjtBQUNoRjs7Q0FFQyxHQUNELElBQUlRO0FBQ0gsVUFBVUEsTUFBTTtJQUNmOzs7Ozs7R0FNQyxHQUNEQSxNQUFNLENBQUMsTUFBTSxHQUFHO0lBQ2hCOzs7O0dBSUMsR0FDREEsTUFBTSxDQUFDLE9BQU8sR0FBRztJQUNqQjs7O0dBR0MsR0FDREEsTUFBTSxDQUFDLFVBQVUsR0FBRztBQUN0QixHQUFHQSxVQUFXQSxDQUFBQSxTQUFTLENBQUM7QUFDeEIsTUFBTUMsb0JBQW9CO0FBQzFCOzs7Q0FHQyxHQUNELFNBQVNDLG9CQUFvQkMsT0FBTztJQUNsQyxJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxJQUFJLEVBQ0ZDLGlCQUFpQjtRQUFDO0tBQUks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V0FBVztZQUNuQ0MsVUFBVXlGLFdBQVd6RixRQUFRO1lBQzdCN0UsTUFBTXNLLFdBQVd0SyxJQUFJO1lBQ3JCOEUsTUFBTXdGLFdBQVd4RixJQUFJO1lBQ3JCN0w7UUFDRjtRQUNBLE9BQU9tVTtJQUNULE9BQU87UUFDTCxJQUFJQSxVQUFVO1lBQ1o5YixPQUFPO1lBQ1BvVCxZQUFZblQ7WUFDWm9ULFlBQVlwVDtZQUNacVQsYUFBYXJUO1lBQ2JzVCxVQUFVdFQ7WUFDVnlPLE1BQU16TztZQUNOdVQsTUFBTXZUO1lBQ04wSDtRQUNGO1FBQ0EsT0FBT21VO0lBQ1Q7QUFDRjtBQUNBLFNBQVN3QixxQkFBcUJ0RSxVQUFVLEVBQUVxRSxlQUFlO0lBQ3ZELElBQUl2QixVQUFVO1FBQ1o5YixPQUFPO1FBQ1BvVCxZQUFZNEYsV0FBVzVGLFVBQVU7UUFDakNDLFlBQVkyRixXQUFXM0YsVUFBVTtRQUNqQ0MsYUFBYTBGLFdBQVcxRixXQUFXO1FBQ25DQyxVQUFVeUYsV0FBV3pGLFFBQVE7UUFDN0I3RSxNQUFNc0ssV0FBV3RLLElBQUk7UUFDckI4RSxNQUFNd0YsV0FBV3hGLElBQUk7UUFDckI3TCxNQUFNMFYsa0JBQWtCQSxnQkFBZ0IxVixJQUFJLEdBQUcxSDtJQUNqRDtJQUNBLE9BQU82YjtBQUNUO0FBQ0EsU0FBUzhCLGVBQWVqVyxJQUFJO0lBQzFCLElBQUltVSxVQUFVO1FBQ1o5YixPQUFPO1FBQ1BvVCxZQUFZblQ7UUFDWm9ULFlBQVlwVDtRQUNacVQsYUFBYXJUO1FBQ2JzVCxVQUFVdFQ7UUFDVnlPLE1BQU16TztRQUNOdVQsTUFBTXZUO1FBQ04wSDtJQUNGO0lBQ0EsT0FBT21VO0FBQ1Q7QUFDQSxZQUFZO0FBRTR3QixDQUN4eEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JvdXRlci9kaXN0L3JvdXRlci5qcz9kODY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHJlbWl4LXJ1bi9yb3V0ZXIgdjEuOS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIEFjdGlvbnMgcmVwcmVzZW50IHRoZSB0eXBlIG9mIGNoYW5nZSB0byBhIGxvY2F0aW9uIHZhbHVlLlxuICovXG52YXIgQWN0aW9uO1xuKGZ1bmN0aW9uIChBY3Rpb24pIHtcbiAgLyoqXG4gICAqIEEgUE9QIGluZGljYXRlcyBhIGNoYW5nZSB0byBhbiBhcmJpdHJhcnkgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2hcbiAgICogYXMgYSBiYWNrIG9yIGZvcndhcmQgbmF2aWdhdGlvbi4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICogbmF2aWdhdGlvbiwgb25seSB0aGF0IHRoZSBjdXJyZW50IGluZGV4IGNoYW5nZWQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBuZXdseSBjcmVhdGVkIGhpc3Rvcnkgb2JqZWN0cy5cbiAgICovXG4gIEFjdGlvbltcIlBvcFwiXSA9IFwiUE9QXCI7XG4gIC8qKlxuICAgKiBBIFBVU0ggaW5kaWNhdGVzIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoIGFzIHdoZW5cbiAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxuICAgKiBlbnRyaWVzIGluIHRoZSBzdGFjayBhcmUgbG9zdC5cbiAgICovXG4gIEFjdGlvbltcIlB1c2hcIl0gPSBcIlBVU0hcIjtcbiAgLyoqXG4gICAqIEEgUkVQTEFDRSBpbmRpY2F0ZXMgdGhlIGVudHJ5IGF0IHRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqIGJlaW5nIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZS5cbiAgICovXG4gIEFjdGlvbltcIlJlcGxhY2VcIl0gPSBcIlJFUExBQ0VcIjtcbn0pKEFjdGlvbiB8fCAoQWN0aW9uID0ge30pKTtcbmNvbnN0IFBvcFN0YXRlRXZlbnRUeXBlID0gXCJwb3BzdGF0ZVwiO1xuLyoqXG4gKiBNZW1vcnkgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gbWVtb3J5LiBJdCBpcyBkZXNpZ25lZCBmb3IgdXNlXG4gKiBpbiBzdGF0ZWZ1bCBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cyBhbmQgUmVhY3QgTmF0aXZlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBsZXQge1xuICAgIGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgdjVDb21wYXQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGVudHJpZXM7IC8vIERlY2xhcmUgc28gd2UgY2FuIGFjY2VzcyBmcm9tIGNyZWF0ZU1lbW9yeUxvY2F0aW9uXG4gIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoKGVudHJ5LCBpbmRleCkgPT4gY3JlYXRlTWVtb3J5TG9jYXRpb24oZW50cnksIHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiA/IG51bGwgOiBlbnRyeS5zdGF0ZSwgaW5kZXggPT09IDAgPyBcImRlZmF1bHRcIiA6IHVuZGVmaW5lZCkpO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4KTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGZ1bmN0aW9uIGNsYW1wSW5kZXgobikge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCAwKSwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIGVudHJpZXNbaW5kZXhdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSwga2V5KSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oZW50cmllcyA/IGdldEN1cnJlbnRMb2NhdGlvbigpLnBhdGhuYW1lIDogXCIvXCIsIHRvLCBzdGF0ZSwga2V5KTtcbiAgICB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsIFwicmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiBcIiArIEpTT04uc3RyaW5naWZ5KHRvKSk7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlVVJMKHRvKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChjcmVhdGVIcmVmKHRvKSwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICAgIH0sXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIGxldCBwYXRoID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICAgICAgc2VhcmNoOiBwYXRoLnNlYXJjaCB8fCBcIlwiLFxuICAgICAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2godG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgZGVsdGE6IDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICBkZWx0YTogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgICAgbGV0IG5leHRJbmRleCA9IGNsYW1wSW5kZXgoaW5kZXggKyBkZWx0YSk7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIGRlbHRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdGVuKGZuKSB7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLyoqXG4gKiBCcm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvclxuICogbW9zdCB3ZWIgYXBwcywgYnV0IGl0IHJlcXVpcmVzIHNvbWUgY29uZmlndXJhdGlvbiBvbiB0aGUgc2VydmVyIHRvIGVuc3VyZSB5b3VcbiAqIHNlcnZlIHRoZSBzYW1lIGFwcCBhdCBtdWx0aXBsZSBVUkxzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlYnJvd3Nlcmhpc3RvcnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2gsXG4gICAgICBoYXNoXG4gICAgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXCJcIiwge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2gsXG4gICAgICBoYXNoXG4gICAgfSxcbiAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCIpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIcmVmKHdpbmRvdywgdG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KGNyZWF0ZUJyb3dzZXJMb2NhdGlvbiwgY3JlYXRlQnJvd3NlckhyZWYsIG51bGwsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBIYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB3aW5kb3cubG9jYXRpb24uaGFzaC4gVGhpcyBtYWtlcyBpdCBpZGVhbFxuICogZm9yIHNpdHVhdGlvbnMgd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgbG9jYXRpb24gdG8gdGhlIHNlcnZlciBmb3JcbiAqIHNvbWUgcmVhc29uLCBlaXRoZXIgYmVjYXVzZSB5b3UgZG8gY2Fubm90IGNvbmZpZ3VyZSBpdCBvciB0aGUgVVJMIHNwYWNlIGlzXG4gKiByZXNlcnZlZCBmb3Igc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVoYXNoaGlzdG9yeVxuICovXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaExvY2F0aW9uKHdpbmRvdywgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgICAgc2VhcmNoID0gXCJcIixcbiAgICAgIGhhc2ggPSBcIlwiXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xuICAgIC8vIEhhc2ggVVJMIHNob3VsZCBhbHdheXMgaGF2ZSBhIGxlYWRpbmcgLyBqdXN0IGxpa2Ugd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgLy8gZG9lcywgc28gaWYgYW4gYXBwIGVuZHMgdXAgYXQgYSByb3V0ZSBsaWtlIC8jc29tZXRoaW5nIHRoZW4gd2UgYWRkIGFcbiAgICAvLyBsZWFkaW5nIHNsYXNoIHNvIGFsbCBvZiBvdXIgcGF0aC1tYXRjaGluZyBiZWhhdmVzIHRoZSBzYW1lIGFzIGlmIGl0IHdvdWxkXG4gICAgLy8gaW4gYSBicm93c2VyIHJvdXRlci4gIFRoaXMgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudCB3aGVuIHRoZXJlIGV4aXN0cyBhXG4gICAgLy8gcm9vdCBzcGxhdCByb3V0ZSAoPFJvdXRlIHBhdGg9XCIqXCI+KSBzaW5jZSB0aGF0IG1hdGNoZXMgaW50ZXJuYWxseSBhZ2FpbnN0XG4gICAgLy8gXCIvKlwiIGFuZCB3ZSdkIGV4cGVjdCAvI3NvbWV0aGluZyB0byA0MDQgaW4gYSBoYXNoIHJvdXRlciBhcHAuXG4gICAgaWYgKCFwYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSAmJiAhcGF0aG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFwiXCIsIHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0sXG4gICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLCBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIYXNoSHJlZih3aW5kb3csIHRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7XG4gICAgbGV0IGhyZWYgPSBcIlwiO1xuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgbGV0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgbGV0IGhhc2hJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGhyZWYgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBocmVmICsgXCIjXCIgKyAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKSk7XG4gIH1cbiAgZnVuY3Rpb24gdmFsaWRhdGVIYXNoTG9jYXRpb24obG9jYXRpb24sIHRvKSB7XG4gICAgd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLCBcInJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaChcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKTtcbiAgfVxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KGNyZWF0ZUhhc2hMb2NhdGlvbiwgY3JlYXRlSGFzaEhyZWYsIHZhbGlkYXRlSGFzaExvY2F0aW9uLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybmluZyhjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIGhpc3RvcnkhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSwgc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG59XG4vKipcbiAqIEZvciBicm93c2VyLWJhc2VkIGhpc3Rvcmllcywgd2UgY29tYmluZSB0aGUgc3RhdGUgYW5kIGtleSBpbnRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgdXNyOiBsb2NhdGlvbi5zdGF0ZSxcbiAgICBrZXk6IGxvY2F0aW9uLmtleSxcbiAgICBpZHg6IGluZGV4XG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBMb2NhdGlvbiBvYmplY3Qgd2l0aCBhIHVuaXF1ZSBrZXkgZnJvbSB0aGUgZ2l2ZW4gUGF0aFxuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihjdXJyZW50LCB0bywgc3RhdGUsIGtleSkge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgIHN0YXRlID0gbnVsbDtcbiAgfVxuICBsZXQgbG9jYXRpb24gPSBfZXh0ZW5kcyh7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCJcbiAgfSwgdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvLCB7XG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogdG8gJiYgdG8ua2V5IHx8IGtleSB8fCBjcmVhdGVLZXkoKVxuICB9KTtcbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIFVSTCBwYXRoIGZyb20gdGhlIGdpdmVuIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhdGgoX3JlZikge1xuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gX3JlZjtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKSBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIikgcGF0aG5hbWUgKz0gaGFzaC5jaGFyQXQoMCkgPT09IFwiI1wiID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbiAgcmV0dXJuIHBhdGhuYW1lO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgVVJMIHBhdGggaW50byBpdHMgc2VwYXJhdGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgbGV0IHBhcnNlZFBhdGggPSB7fTtcbiAgaWYgKHBhdGgpIHtcbiAgICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAoc2VhcmNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5zZWFyY2ggPSBwYXRoLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICAgIH1cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuZnVuY3Rpb24gZ2V0VXJsQmFzZWRIaXN0b3J5KGdldExvY2F0aW9uLCBjcmVhdGVIcmVmLCB2YWxpZGF0ZUxvY2F0aW9uLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgbGV0IHtcbiAgICB3aW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyxcbiAgICB2NUNvbXBhdCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgbGV0IGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgLy8gSW5kZXggc2hvdWxkIG9ubHkgYmUgbnVsbCB3aGVuIHdlIGluaXRpYWxpemUuIElmIG5vdCwgaXQncyBiZWNhdXNlIHRoZVxuICAvLyB1c2VyIGNhbGxlZCBoaXN0b3J5LnB1c2hTdGF0ZSBvciBoaXN0b3J5LnJlcGxhY2VTdGF0ZSBkaXJlY3RseSwgaW4gd2hpY2hcbiAgLy8gY2FzZSB3ZSBzaG91bGQgbG9nIGEgd2FybmluZyBhcyBpdCB3aWxsIHJlc3VsdCBpbiBidWdzLlxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSwge1xuICAgICAgaWR4OiBpbmRleFxuICAgIH0pLCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbmRleCgpIHtcbiAgICBsZXQgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHtcbiAgICAgIGlkeDogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHN0YXRlLmlkeDtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICBsZXQgbmV4dEluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgZGVsdGEgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXggLSBpbmRleDtcbiAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcbiAgICBpbmRleCA9IGdldEluZGV4KCkgKyAxO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSBleGNlcHRpb24gaXMgYmVjYXVzZSBgc3RhdGVgIGNhbid0IGJlIHNlcmlhbGl6ZWQsIGxldCB0aGF0IHRocm93XG4gICAgICAvLyBvdXR3YXJkcyBqdXN0IGxpa2UgYSByZXBsYWNlIGNhbGwgd291bGQgc28gdGhlIGRldiBrbm93cyB0aGUgY2F1c2VcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL25hdi1oaXN0b3J5LWFwaXMuaHRtbCNzaGFyZWQtaGlzdG9yeS1wdXNoL3JlcGxhY2Utc3RhdGUtc3RlcHNcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N0cnVjdHVyZWQtZGF0YS5odG1sI3N0cnVjdHVyZWRzZXJpYWxpemVpbnRlcm5hbFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiRGF0YUNsb25lRXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICBkZWx0YTogMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICBkZWx0YTogMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVVSTCh0bykge1xuICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gaXMgXCJudWxsXCIgKHRoZSBsaXRlcmFsIHN0cmluZyB2YWx1ZSkgaW4gRmlyZWZveFxuICAgIC8vIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucywgbm90YWJseSB3aGVuIHNlcnZpbmcgZnJvbSBhIGxvY2FsIEhUTUwgZmlsZVxuICAgIC8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04NzgyOTdcbiAgICBsZXQgYmFzZSA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gIT09IFwibnVsbFwiID8gd2luZG93LmxvY2F0aW9uLm9yaWdpbiA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgIGxldCBocmVmID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICBpbnZhcmlhbnQoYmFzZSwgXCJObyB3aW5kb3cubG9jYXRpb24uKG9yaWdpbnxocmVmKSBhdmFpbGFibGUgdG8gY3JlYXRlIFVSTCBmb3IgaHJlZjogXCIgKyBocmVmKTtcbiAgICByZXR1cm4gbmV3IFVSTChocmVmLCBiYXNlKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpO1xuICAgIH0sXG4gICAgbGlzdGVuKGZuKSB7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBoaXN0b3J5IG9ubHkgYWNjZXB0cyBvbmUgYWN0aXZlIGxpc3RlbmVyXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSHJlZih3aW5kb3csIHRvKTtcbiAgICB9LFxuICAgIGNyZWF0ZVVSTCxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgLy8gRW5jb2RlIGEgTG9jYXRpb24gdGhlIHNhbWUgd2F5IHdpbmRvdy5sb2NhdGlvbiB3b3VsZFxuICAgICAgbGV0IHVybCA9IGNyZWF0ZVVSTCh0byk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCxcbiAgICByZXBsYWNlLFxuICAgIGdvKG4pIHtcbiAgICAgIHJldHVybiBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vLyNlbmRyZWdpb25cblxudmFyIFJlc3VsdFR5cGU7XG4oZnVuY3Rpb24gKFJlc3VsdFR5cGUpIHtcbiAgUmVzdWx0VHlwZVtcImRhdGFcIl0gPSBcImRhdGFcIjtcbiAgUmVzdWx0VHlwZVtcImRlZmVycmVkXCJdID0gXCJkZWZlcnJlZFwiO1xuICBSZXN1bHRUeXBlW1wicmVkaXJlY3RcIl0gPSBcInJlZGlyZWN0XCI7XG4gIFJlc3VsdFR5cGVbXCJlcnJvclwiXSA9IFwiZXJyb3JcIjtcbn0pKFJlc3VsdFR5cGUgfHwgKFJlc3VsdFR5cGUgPSB7fSkpO1xuY29uc3QgaW1tdXRhYmxlUm91dGVLZXlzID0gbmV3IFNldChbXCJsYXp5XCIsIFwiY2FzZVNlbnNpdGl2ZVwiLCBcInBhdGhcIiwgXCJpZFwiLCBcImluZGV4XCIsIFwiY2hpbGRyZW5cIl0pO1xuZnVuY3Rpb24gaXNJbmRleFJvdXRlKHJvdXRlKSB7XG4gIHJldHVybiByb3V0ZS5pbmRleCA9PT0gdHJ1ZTtcbn1cbi8vIFdhbGsgdGhlIHJvdXRlIHRyZWUgZ2VuZXJhdGluZyB1bmlxdWUgSURzIHdoZXJlIG5lY2Vzc2FyeSwgc28gd2UgYXJlIHdvcmtpbmdcbi8vIHNvbGVseSB3aXRoIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0J3Mgd2l0aGluIHRoZSBSb3V0ZXJcbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMsIHBhcmVudFBhdGgsIG1hbmlmZXN0KSB7XG4gIGlmIChwYXJlbnRQYXRoID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRQYXRoID0gW107XG4gIH1cbiAgaWYgKG1hbmlmZXN0ID09PSB2b2lkIDApIHtcbiAgICBtYW5pZmVzdCA9IHt9O1xuICB9XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGxldCBpZCA9IHR5cGVvZiByb3V0ZS5pZCA9PT0gXCJzdHJpbmdcIiA/IHJvdXRlLmlkIDogdHJlZVBhdGguam9pbihcIi1cIik7XG4gICAgaW52YXJpYW50KHJvdXRlLmluZGV4ICE9PSB0cnVlIHx8ICFyb3V0ZS5jaGlsZHJlbiwgXCJDYW5ub3Qgc3BlY2lmeSBjaGlsZHJlbiBvbiBhbiBpbmRleCByb3V0ZVwiKTtcbiAgICBpbnZhcmlhbnQoIW1hbmlmZXN0W2lkXSwgXCJGb3VuZCBhIHJvdXRlIGlkIGNvbGxpc2lvbiBvbiBpZCBcXFwiXCIgKyBpZCArIFwiXFxcIi4gIFJvdXRlIFwiICsgXCJpZCdzIG11c3QgYmUgZ2xvYmFsbHkgdW5pcXVlIHdpdGhpbiBEYXRhIFJvdXRlciB1c2FnZXNcIik7XG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGxldCBpbmRleFJvdXRlID0gX2V4dGVuZHMoe30sIHJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGUpLCB7XG4gICAgICAgIGlkXG4gICAgICB9KTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IGluZGV4Um91dGU7XG4gICAgICByZXR1cm4gaW5kZXhSb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhdGhPckxheW91dFJvdXRlID0gX2V4dGVuZHMoe30sIHJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGUpLCB7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IHBhdGhPckxheW91dFJvdXRlO1xuICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgIHBhdGhPckxheW91dFJvdXRlLmNoaWxkcmVuID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgbWFwUm91dGVQcm9wZXJ0aWVzLCB0cmVlUGF0aCwgbWFuaWZlc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhPckxheW91dFJvdXRlO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcm91dGVzXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lKSB7XG4gIGlmIChiYXNlbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZW5hbWUgPSBcIi9cIjtcbiAgfVxuICBsZXQgbG9jYXRpb24gPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaGVzW2ldLFxuICAgIC8vIEluY29taW5nIHBhdGhuYW1lcyBhcmUgZ2VuZXJhbGx5IGVuY29kZWQgZnJvbSBlaXRoZXIgd2luZG93LmxvY2F0aW9uXG4gICAgLy8gb3IgZnJvbSByb3V0ZXIubmF2aWdhdGUsIGJ1dCB3ZSB3YW50IHRvIG1hdGNoIGFnYWluc3QgdGhlIHVuZW5jb2RlZFxuICAgIC8vIHBhdGhzIGluIHRoZSByb3V0ZSBkZWZpbml0aW9ucy4gIE1lbW9yeSByb3V0ZXIgbG9jYXRpb25zIHdvbid0IGJlXG4gICAgLy8gZW5jb2RlZCBoZXJlIGJ1dCB0aGVyZSBhbHNvIHNob3VsZG4ndCBiZSBhbnl0aGluZyB0byBkZWNvZGUgc28gdGhpc1xuICAgIC8vIHNob3VsZCBiZSBhIHNhZmUgb3BlcmF0aW9uLiAgVGhpcyBhdm9pZHMgbmVlZGluZyBtYXRjaFJvdXRlcyB0byBiZVxuICAgIC8vIGhpc3RvcnktYXdhcmUuXG4gICAgc2FmZWx5RGVjb2RlVVJJKHBhdGhuYW1lKSk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtYXRjaCwgbG9hZGVyRGF0YSkge1xuICBsZXQge1xuICAgIHJvdXRlLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtc1xuICB9ID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJvdXRlLmlkLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkYXRhOiBsb2FkZXJEYXRhW3JvdXRlLmlkXSxcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZVxuICB9O1xufVxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhyb3V0ZXMsIGJyYW5jaGVzLCBwYXJlbnRzTWV0YSwgcGFyZW50UGF0aCkge1xuICBpZiAoYnJhbmNoZXMgPT09IHZvaWQgMCkge1xuICAgIGJyYW5jaGVzID0gW107XG4gIH1cbiAgaWYgKHBhcmVudHNNZXRhID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRzTWV0YSA9IFtdO1xuICB9XG4gIGlmIChwYXJlbnRQYXRoID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRQYXRoID0gXCJcIjtcbiAgfVxuICBsZXQgZmxhdHRlblJvdXRlID0gKHJvdXRlLCBpbmRleCwgcmVsYXRpdmVQYXRoKSA9PiB7XG4gICAgbGV0IG1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJlbGF0aXZlUGF0aCA9PT0gdW5kZWZpbmVkID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGVcbiAgICB9O1xuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCksIFwiQWJzb2x1dGUgcm91dGUgcGF0aCBcXFwiXCIgKyBtZXRhLnJlbGF0aXZlUGF0aCArIFwiXFxcIiBuZXN0ZWQgdW5kZXIgcGF0aCBcIiArIChcIlxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIFwiKSArIFwibXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5cIik7XG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG4gICAgLy8gQWRkIHRoZSBjaGlsZHJlbiBiZWZvcmUgYWRkaW5nIHRoaXMgcm91dGUgdG8gdGhlIGFycmF5LCBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgLy8gT3VyIHR5cGVzIGtub3cgYmV0dGVyLCBidXQgcnVudGltZSBKUyBtYXkgbm90IVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsIFwiSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIFwiICsgKFwiYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIi5cIikpO1xuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJyYW5jaGVzLnB1c2goe1xuICAgICAgcGF0aCxcbiAgICAgIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLFxuICAgICAgcm91dGVzTWV0YVxuICAgIH0pO1xuICB9O1xuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgdmFyIF9yb3V0ZSRwYXRoO1xuICAgIC8vIGNvYXJzZS1ncmFpbiBjaGVjayBmb3Igb3B0aW9uYWwgcGFyYW1zXG4gICAgaWYgKHJvdXRlLnBhdGggPT09IFwiXCIgfHwgISgoX3JvdXRlJHBhdGggPSByb3V0ZS5wYXRoKSAhPSBudWxsICYmIF9yb3V0ZSRwYXRoLmluY2x1ZGVzKFwiP1wiKSkpIHtcbiAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBleHBsb2RlZCBvZiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyb3V0ZS5wYXRoKSkge1xuICAgICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4LCBleHBsb2RlZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuLyoqXG4gKiBDb21wdXRlcyBhbGwgY29tYmluYXRpb25zIG9mIG9wdGlvbmFsIHBhdGggc2VnbWVudHMgZm9yIGEgZ2l2ZW4gcGF0aCxcbiAqIGV4Y2x1ZGluZyBjb21iaW5hdGlvbnMgdGhhdCBhcmUgYW1iaWd1b3VzIGFuZCBvZiBsb3dlciBwcmlvcml0eS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYC9vbmUvOnR3bz8vdGhyZWUvOmZvdXI/LzpmaXZlP2AgZXhwbG9kZXMgdG86XG4gKiAtIGAvb25lL3RocmVlYFxuICogLSBgL29uZS86dHdvL3RocmVlYFxuICogLSBgL29uZS90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyLzpmaXZlYFxuICovXG5mdW5jdGlvbiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhwYXRoKSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gc2VnbWVudHM7XG4gIC8vIE9wdGlvbmFsIHBhdGggc2VnbWVudHMgYXJlIGRlbm90ZWQgYnkgYSB0cmFpbGluZyBgP2BcbiAgbGV0IGlzT3B0aW9uYWwgPSBmaXJzdC5lbmRzV2l0aChcIj9cIik7XG4gIC8vIENvbXB1dGUgdGhlIGNvcnJlc3BvbmRpbmcgcmVxdWlyZWQgc2VnbWVudDogYGZvbz9gIC0+IGBmb29gXG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSW50ZXByZXQgZW1wdHkgc3RyaW5nIGFzIG9taXR0aW5nIGFuIG9wdGlvbmFsIHNlZ21lbnRcbiAgICAvLyBgW1wib25lXCIsIFwiXCIsIFwidGhyZWVcIl1gIGNvcnJlc3BvbmRzIHRvIG9taXR0aW5nIGA6dHdvYCBmcm9tIGAvb25lLzp0d28/L3RocmVlYCAtPiBgL29uZS90aHJlZWBcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG4gIGxldCByZXN0RXhwbG9kZWQgPSBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyZXN0LmpvaW4oXCIvXCIpKTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICAvLyBBbGwgY2hpbGQgcGF0aHMgd2l0aCB0aGUgcHJlZml4LiAgRG8gdGhpcyBmb3IgYWxsIGNoaWxkcmVuIGJlZm9yZSB0aGVcbiAgLy8gb3B0aW9uYWwgdmVyc2lvbiBmb3IgYWxsIGNoaWxkcmVuLCBzbyB3ZSBnZXQgY29uc2lzdGVudCBvcmRlcmluZyB3aGVyZSB0aGVcbiAgLy8gcGFyZW50IG9wdGlvbmFsIGFzcGVjdCBpcyBwcmVmZXJyZWQgYXMgcmVxdWlyZWQuICBPdGhlcndpc2UsIHdlIGNhbiBnZXRcbiAgLy8gY2hpbGQgc2VjdGlvbnMgaW50ZXJzcGVyc2VkIHdoZXJlIGRlZXBlciBvcHRpb25hbCBzZWdtZW50cyBhcmUgaGlnaGVyIHRoYW5cbiAgLy8gcGFyZW50IG9wdGlvbmFsIHNlZ21lbnRzLCB3aGVyZSBmb3IgZXhhbXBsZSwgLzp0d28gd291bGQgZXhwbG9kZSBfZWFybGllcl9cbiAgLy8gdGhlbiAvOm9uZS4gIEJ5IGFsd2F5cyBpbmNsdWRpbmcgdGhlIHBhcmVudCBhcyByZXF1aXJlZCBfZm9yIGFsbCBjaGlsZHJlbl9cbiAgLy8gZmlyc3QsIHdlIGF2b2lkIHRoaXMgaXNzdWVcbiAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkLm1hcChzdWJwYXRoID0+IHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIikpKTtcbiAgLy8gVGhlbiwgaWYgdGhpcyBpcyBhbiBvcHRpb25hbCB2YWx1ZSwgYWRkIGFsbCBjaGlsZCB2ZXJzaW9ucyB3aXRob3V0XG4gIGlmIChpc09wdGlvbmFsKSB7XG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcbiAgfVxuICAvLyBmb3IgYWJzb2x1dGUgcGF0aHMsIGVuc3VyZSBgL2AgaW5zdGVhZCBvZiBlbXB0eSBzZWdtZW50XG4gIHJldHVybiByZXN1bHQubWFwKGV4cGxvZGVkID0+IHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkKTtcbn1cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKSB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+IGEuc2NvcmUgIT09IGIuc2NvcmUgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgOiBjb21wYXJlSW5kZXhlcyhhLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSwgYi5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCkpKTtcbn1cbmNvbnN0IHBhcmFtUmUgPSAvXjpcXHcrJC87XG5jb25zdCBkeW5hbWljU2VnbWVudFZhbHVlID0gMztcbmNvbnN0IGluZGV4Um91dGVWYWx1ZSA9IDI7XG5jb25zdCBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG5jb25zdCBzdGF0aWNTZWdtZW50VmFsdWUgPSAxMDtcbmNvbnN0IHNwbGF0UGVuYWx0eSA9IC0yO1xuY29uc3QgaXNTcGxhdCA9IHMgPT4gcyA9PT0gXCIqXCI7XG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aCwgaW5kZXgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG4gIHJldHVybiBzZWdtZW50cy5maWx0ZXIocyA9PiAhaXNTcGxhdChzKSkucmVkdWNlKChzY29yZSwgc2VnbWVudCkgPT4gc2NvcmUgKyAocGFyYW1SZS50ZXN0KHNlZ21lbnQpID8gZHluYW1pY1NlZ21lbnRWYWx1ZSA6IHNlZ21lbnQgPT09IFwiXCIgPyBlbXB0eVNlZ21lbnRWYWx1ZSA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksIGluaXRpYWxTY29yZSk7XG59XG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhLCBiKSB7XG4gIGxldCBzaWJsaW5ncyA9IGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG4gIHJldHVybiBzaWJsaW5ncyA/XG4gIC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXSA6XG4gIC8vIE90aGVyd2lzZSwgaXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSB0byByYW5rIG5vbi1zaWJsaW5ncyBieSBpbmRleCxcbiAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gIDA7XG59XG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaCwgcGF0aG5hbWUpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXNNZXRhXG4gIH0gPSBicmFuY2g7XG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZFBhdGhuYW1lID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UobWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKHtcbiAgICAgIHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZW5kXG4gICAgfSwgcmVtYWluaW5nUGF0aG5hbWUpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAvLyBUT0RPOiBDYW4gdGhpcyBhcyBiZSBhdm9pZGVkP1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSkpLFxuICAgICAgcm91dGVcbiAgICB9KTtcbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbi8qKlxuICogUmV0dXJucyBhIHBhdGggd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvZ2VuZXJhdGUtcGF0aFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgob3JpZ2luYWxQYXRoLCBwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cbiAgbGV0IHBhdGggPSBvcmlnaW5hbFBhdGg7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBwYXRoICE9PSBcIipcIiAmJiAhcGF0aC5lbmRzV2l0aChcIi8qXCIpKSB7XG4gICAgd2FybmluZyhmYWxzZSwgXCJSb3V0ZSBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgXCIgKyAoXCJcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiIGJlY2F1c2UgdGhlIGAqYCBjaGFyYWN0ZXIgbXVzdCBcIikgKyBcImFsd2F5cyBmb2xsb3cgYSBgL2AgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBcIiArIChcInBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIi5cIikpO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpO1xuICB9XG4gIC8vIGVuc3VyZSBgL2AgaXMgYWRkZWQgYXQgdGhlIGJlZ2lubmluZyBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZVxuICBjb25zdCBwcmVmaXggPSBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCIvXCIgOiBcIlwiO1xuICBjb25zdCBzdHJpbmdpZnkgPSBwID0+IHAgPT0gbnVsbCA/IFwiXCIgOiB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHAgOiBTdHJpbmcocCk7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pLm1hcCgoc2VnbWVudCwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxO1xuICAgIC8vIG9ubHkgYXBwbHkgdGhlIHNwbGF0IGlmIGl0J3MgdGhlIGxhc3Qgc2VnbWVudFxuICAgIGlmIChpc0xhc3RTZWdtZW50ICYmIHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgICBjb25zdCBzdGFyID0gXCIqXCI7XG4gICAgICAvLyBBcHBseSB0aGUgc3BsYXRcbiAgICAgIHJldHVybiBzdHJpbmdpZnkocGFyYW1zW3N0YXJdKTtcbiAgICB9XG4gICAgY29uc3Qga2V5TWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihcXHcrKShcXD8/KSQvKTtcbiAgICBpZiAoa2V5TWF0Y2gpIHtcbiAgICAgIGNvbnN0IFssIGtleSwgb3B0aW9uYWxdID0ga2V5TWF0Y2g7XG4gICAgICBsZXQgcGFyYW0gPSBwYXJhbXNba2V5XTtcbiAgICAgIGludmFyaWFudChvcHRpb25hbCA9PT0gXCI/XCIgfHwgcGFyYW0gIT0gbnVsbCwgXCJNaXNzaW5nIFxcXCI6XCIgKyBrZXkgKyBcIlxcXCIgcGFyYW1cIik7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFueSBvcHRpb25hbCBtYXJrZXJzIGZyb20gb3B0aW9uYWwgc3RhdGljIHNlZ21lbnRzXG4gICAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvXFw/JC9nLCBcIlwiKTtcbiAgfSlcbiAgLy8gUmVtb3ZlIGVtcHR5IHNlZ21lbnRzXG4gIC5maWx0ZXIoc2VnbWVudCA9PiAhIXNlZ21lbnQpO1xuICByZXR1cm4gcHJlZml4ICsgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG4vKipcbiAqIFBlcmZvcm1zIHBhdHRlcm4gbWF0Y2hpbmcgb24gYSBVUkwgcGF0aG5hbWUgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHRoZSBtYXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXBhdGhcbiAqL1xuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7XG4gICAgICBwYXRoOiBwYXR0ZXJuLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICBlbmQ6IHRydWVcbiAgICB9O1xuICB9XG4gIGxldCBbbWF0Y2hlciwgcGFyYW1OYW1lc10gPSBjb21waWxlUGF0aChwYXR0ZXJuLnBhdGgsIHBhdHRlcm4uY2FzZVNlbnNpdGl2ZSwgcGF0dGVybi5lbmQpO1xuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXMgPSBwYXJhbU5hbWVzLnJlZHVjZSgobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICB9XG4gICAgbWVtb1twYXJhbU5hbWVdID0gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCIsIHBhcmFtTmFtZSk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVyblxuICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCwgY2FzZVNlbnNpdGl2ZSwgZW5kKSB7XG4gIGlmIChjYXNlU2Vuc2l0aXZlID09PSB2b2lkIDApIHtcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgZW5kID0gdHJ1ZTtcbiAgfVxuICB3YXJuaW5nKHBhdGggPT09IFwiKlwiIHx8ICFwYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXRoLmVuZHNXaXRoKFwiLypcIiksIFwiUm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiICsgKFwiXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIiBiZWNhdXNlIHRoZSBgKmAgY2hhcmFjdGVyIG11c3QgXCIpICsgXCJhbHdheXMgZm9sbG93IGEgYC9gIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgXCIgKyAoXCJwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIuXCIpKTtcbiAgbGV0IHBhcmFtTmFtZXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAucmVwbGFjZSgvW1xcXFwuKiteJD97fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gIC5yZXBsYWNlKC9cXC86KFxcdyspL2csIChfLCBwYXJhbU5hbWUpID0+IHtcbiAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICByZXR1cm4gXCIvKFteXFxcXC9dKylcIjtcbiAgfSk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtTmFtZXMucHVzaChcIipcIik7XG4gICAgcmVnZXhwU291cmNlICs9IHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIiA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjsgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgLyBpbiBwYXJhbXNbXCIqXCJdXG4gIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIlxcXFwvKiRcIjtcbiAgfSBlbHNlIGlmIChwYXRoICE9PSBcIlwiICYmIHBhdGggIT09IFwiL1wiKSB7XG4gICAgLy8gSWYgb3VyIHBhdGggaXMgbm9uLWVtcHR5IGFuZCBjb250YWlucyBhbnl0aGluZyBiZXlvbmQgYW4gaW5pdGlhbCBzbGFzaCxcbiAgICAvLyB0aGVuIHdlIGhhdmUgX3NvbWVfIGZvcm0gb2YgcGF0aCBpbiBvdXIgcmVnZXgsIHNvIHdlIHNob3VsZCBleHBlY3QgdG9cbiAgICAvLyBtYXRjaCBvbmx5IGlmIHdlIGZpbmQgdGhlIGVuZCBvZiB0aGlzIHBhdGggc2VnbWVudC4gIExvb2sgZm9yIGFuIG9wdGlvbmFsXG4gICAgLy8gbm9uLWNhcHR1cmVkIHRyYWlsaW5nIHNsYXNoICh0byBtYXRjaCBhIHBvcnRpb24gb2YgdGhlIFVSTCkgb3IgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBwYXRoIChpZiB3ZSd2ZSBtYXRjaGVkIHRvIHRoZSBlbmQpLiAgV2UgdXNlZCB0byBkbyB0aGlzIHdpdGggYVxuICAgIC8vIHdvcmQgYm91bmRhcnkgYnV0IHRoYXQgZ2l2ZXMgZmFsc2UgcG9zaXRpdmVzIG9uIHJvdXRlcyBsaWtlXG4gICAgLy8gL3VzZXItcHJlZmVyZW5jZXMgc2luY2UgYC1gIGNvdW50cyBhcyBhIHdvcmQgYm91bmRhcnkuXG4gICAgcmVnZXhwU291cmNlICs9IFwiKD86KD89XFxcXC98JCkpXCI7XG4gIH0gZWxzZSA7XG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiBcImlcIik7XG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1OYW1lc107XG59XG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUkkodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSBVUkwgcGF0aCBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiBjb3VsZCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlIGl0IGlzIGlzIGEgXCIgKyBcIm1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBcIiArIChcImVuY29kaW5nIChcIiArIGVycm9yICsgXCIpLlwiKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQodmFsdWUsIHBhcmFtTmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiVGhlIHZhbHVlIGZvciB0aGUgVVJMIHBhcmFtIFxcXCJcIiArIHBhcmFtTmFtZSArIFwiXFxcIiB3aWxsIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2VcIiArIChcIiB0aGUgc3RyaW5nIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiIGlzIGEgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5XCIpICsgKFwiIGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nIChcIiArIGVycm9yICsgXCIpLlwiKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKSB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBXZSB3YW50IHRvIGxlYXZlIHRyYWlsaW5nIHNsYXNoIGJlaGF2aW9yIGluIHRoZSB1c2VyJ3MgY29udHJvbCwgc28gaWYgdGhleVxuICAvLyBzcGVjaWZ5IGEgYmFzZW5hbWUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLCB3ZSBzaG91bGQgc3VwcG9ydCBpdFxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IGJhc2VuYW1lLmxlbmd0aCAtIDEgOiBiYXNlbmFtZS5sZW5ndGg7XG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChzdGFydEluZGV4KTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIC8vIHBhdGhuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggYmFzZW5hbWUvXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvcmVzb2x2ZS1wYXRoXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvLCBmcm9tUGF0aG5hbWUpIHtcbiAgaWYgKGZyb21QYXRobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgZnJvbVBhdGhuYW1lID0gXCIvXCI7XG4gIH1cbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWUgPyB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZSA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpIDogZnJvbVBhdGhuYW1lO1xuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaDogbm9ybWFsaXplU2VhcmNoKHNlYXJjaCksXG4gICAgaGFzaDogbm9ybWFsaXplSGFzaChoYXNoKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHJlbGF0aXZlUGF0aCwgZnJvbVBhdGhuYW1lKSB7XG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgbGV0IHJlbGF0aXZlU2VnbWVudHMgPSByZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpO1xuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goc2VnbWVudCA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgLy8gS2VlcCB0aGUgcm9vdCBcIlwiIHNlZ21lbnQgc28gdGhlIHBhdGhuYW1lIHN0YXJ0cyBhdCAvXG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID4gMSA/IHNlZ21lbnRzLmpvaW4oXCIvXCIpIDogXCIvXCI7XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkUGF0aEVycm9yKGNoYXIsIGZpZWxkLCBkZXN0LCBwYXRoKSB7XG4gIHJldHVybiBcIkNhbm5vdCBpbmNsdWRlIGEgJ1wiICsgY2hhciArIFwiJyBjaGFyYWN0ZXIgaW4gYSBtYW51YWxseSBzcGVjaWZpZWQgXCIgKyAoXCJgdG8uXCIgKyBmaWVsZCArIFwiYCBmaWVsZCBbXCIgKyBKU09OLnN0cmluZ2lmeShwYXRoKSArIFwiXS4gIFBsZWFzZSBzZXBhcmF0ZSBpdCBvdXQgdG8gdGhlIFwiKSArIChcImB0by5cIiArIGRlc3QgKyBcImAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgXCIpICsgXCJhIHN0cmluZyBpbiA8TGluayB0bz1cXFwiLi4uXFxcIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LlwiO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFdoZW4gcHJvY2Vzc2luZyByZWxhdGl2ZSBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gaWdub3JlIGFuY2VzdG9yIHJvdXRlcyB0aGF0XG4gKiBkbyBub3QgY29udHJpYnV0ZSB0byB0aGUgcGF0aCwgc3VjaCB0aGF0IGluZGV4L3BhdGhsZXNzIGxheW91dCByb3V0ZXMgZG9uJ3RcbiAqIGludGVyZmVyZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgd2hlbiBtb3ZpbmcgYSByb3V0ZSBlbGVtZW50IGludG8gYW4gaW5kZXggcm91dGUgYW5kL29yIGFcbiAqIHBhdGhsZXNzIGxheW91dCByb3V0ZSwgcmVsYXRpdmUgbGluayBiZWhhdmlvciBjb250YWluZWQgd2l0aGluIHNob3VsZCBzdGF5XG4gKiB0aGUgc2FtZS4gIEJvdGggb2YgdGhlIGZvbGxvd2luZyBleGFtcGxlcyBzaG91bGQgbGluayBiYWNrIHRvIHRoZSByb290OlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiIGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0+XG4gKiAgIDwvUm91dGU+XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cbiAqICAgICA8Um91dGUgcGF0aD1cImFjY291bnRzXCI+XG4gKiAgICAgICA8Um91dGUgZWxlbWVudD17PEFjY291bnRzTGF5b3V0IC8+fT4gICAgICAgLy8gPC0tIERvZXMgbm90IGNvbnRyaWJ1dGVcbiAqICAgICAgICAgPFJvdXRlIGluZGV4IGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0gLz4gIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICA8L1JvdXRlXG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgPC9Sb3V0ZT5cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4gaW5kZXggPT09IDAgfHwgbWF0Y2gucm91dGUucGF0aCAmJiBtYXRjaC5yb3V0ZS5wYXRoLmxlbmd0aCA+IDApO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlVG8odG9BcmcsIHJvdXRlUGF0aG5hbWVzLCBsb2NhdGlvblBhdGhuYW1lLCBpc1BhdGhSZWxhdGl2ZSkge1xuICBpZiAoaXNQYXRoUmVsYXRpdmUgPT09IHZvaWQgMCkge1xuICAgIGlzUGF0aFJlbGF0aXZlID0gZmFsc2U7XG4gIH1cbiAgbGV0IHRvO1xuICBpZiAodHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG8gPSBwYXJzZVBhdGgodG9BcmcpO1xuICB9IGVsc2Uge1xuICAgIHRvID0gX2V4dGVuZHMoe30sIHRvQXJnKTtcbiAgICBpbnZhcmlhbnQoIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksIGdldEludmFsaWRQYXRoRXJyb3IoXCI/XCIsIFwicGF0aG5hbWVcIiwgXCJzZWFyY2hcIiwgdG8pKTtcbiAgICBpbnZhcmlhbnQoIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwicGF0aG5hbWVcIiwgXCJoYXNoXCIsIHRvKSk7XG4gICAgaW52YXJpYW50KCF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCB0bykpO1xuICB9XG4gIGxldCBpc0VtcHR5UGF0aCA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiO1xuICBsZXQgdG9QYXRobmFtZSA9IGlzRW1wdHlQYXRoID8gXCIvXCIgOiB0by5wYXRobmFtZTtcbiAgbGV0IGZyb207XG4gIC8vIFJvdXRpbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGF0aG5hbWUgaWYgZXhwbGljaXRseSByZXF1ZXN0ZWQuXG4gIC8vXG4gIC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cbiAgaWYgKGlzUGF0aFJlbGF0aXZlIHx8IHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgIC8vIEVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZVxuICAgICAgLy8gVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXkgZGlmZmVyZW5jZSBmcm9tIGhvdyA8YSBocmVmPiB3b3JrcyBhbmQgYVxuICAgICAgLy8gbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG4gICAgICB3aGlsZSAodG9TZWdtZW50c1swXSA9PT0gXCIuLlwiKSB7XG4gICAgICAgIHRvU2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgcm91dGVQYXRobmFtZUluZGV4IC09IDE7XG4gICAgICB9XG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIFwidG9cIiBoYWQgb25lXG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPSB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPSAoaXNFbXB0eVBhdGggfHwgdG9QYXRobmFtZSA9PT0gXCIuXCIpICYmIGxvY2F0aW9uUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBpZiAoIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bykge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lIDogdG8ucGF0aG5hbWU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGpvaW5QYXRocyA9IHBhdGhzID0+IHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBub3JtYWxpemVQYXRobmFtZSA9IHBhdGhuYW1lID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IHNlYXJjaCA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSBoYXNoID0+ICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5jb25zdCBqc29uID0gZnVuY3Rpb24ganNvbihkYXRhLCBpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0ge307XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8ge1xuICAgIHN0YXR1czogaW5pdFxuICB9IDogaW5pdDtcbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwgX2V4dGVuZHMoe30sIHJlc3BvbnNlSW5pdCwge1xuICAgIGhlYWRlcnNcbiAgfSkpO1xufTtcbmNsYXNzIEFib3J0ZWREZWZlcnJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmNsYXNzIERlZmVycmVkRGF0YSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlc3BvbnNlSW5pdCkge1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRlZmVycmVkS2V5cyA9IFtdO1xuICAgIGludmFyaWFudChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpLCBcImRlZmVyKCkgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHNcIik7XG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XG4gICAgLy8gY2FuY2VsbGF0aW9uXG4gICAgbGV0IHJlamVjdDtcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG9uQWJvcnQgPSAoKSA9PiByZWplY3QobmV3IEFib3J0ZWREZWZlcnJlZEVycm9yKFwiRGVmZXJyZWQgZGF0YSBhYm9ydGVkXCIpKTtcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgX3JlZikgPT4ge1xuICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgW2tleV06IHRoaXMudHJhY2tQcm9taXNlKGtleSwgdmFsdWUpXG4gICAgICB9KTtcbiAgICB9LCB7fSk7XG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gQWxsIGluY29taW5nIHZhbHVlcyB3ZXJlIHJlc29sdmVkXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG4gICAgdGhpcy5pbml0ID0gcmVzcG9uc2VJbml0O1xuICB9XG4gIHRyYWNrUHJvbWlzZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLmRlZmVycmVkS2V5cy5wdXNoKGtleSk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5hZGQoa2V5KTtcbiAgICAvLyBXZSBzdG9yZSBhIGxpdHRsZSB3cmFwcGVyIHByb21pc2UgdGhhdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGhcbiAgICAvLyBfZGF0YS9fZXJyb3IgcHJvcHMgdXBvbiByZXNvbHZlL3JlamVjdFxuICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5yYWNlKFt2YWx1ZSwgdGhpcy5hYm9ydFByb21pc2VdKS50aGVuKGRhdGEgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIHVuZGVmaW5lZCwgZGF0YSksIGVycm9yID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvcikpO1xuICAgIC8vIFJlZ2lzdGVyIHJlamVjdGlvbiBsaXN0ZW5lcnMgdG8gYXZvaWQgdW5jYXVnaHQgcHJvbWlzZSByZWplY3Rpb25zIG9uXG4gICAgLy8gZXJyb3JzIG9yIGFib3J0ZWQgZGVmZXJyZWQgdmFsdWVzXG4gICAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgb25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvciwgZGF0YSkge1xuICAgIGlmICh0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiYgZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvcikge1xuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGFib3J0IVxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwcm9taXNlIHdhcyByZXNvbHZlZC9yZWplY3RlZCB3aXRoIHVuZGVmaW5lZCwgd2UnbGwgdGhyb3cgYW4gZXJyb3IgYXMgeW91XG4gICAgLy8gc2hvdWxkIGFsd2F5cyByZXNvbHZlIHdpdGggYSB2YWx1ZSBvciBudWxsXG4gICAgaWYgKGVycm9yID09PSB1bmRlZmluZWQgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgdW5kZWZpbmVkRXJyb3IgPSBuZXcgRXJyb3IoXCJEZWZlcnJlZCBkYXRhIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJlc29sdmVkL3JlamVjdGVkIHdpdGggYHVuZGVmaW5lZGAsIFwiICsgXCJ5b3UgbXVzdCByZXNvbHZlL3JlamVjdCB3aXRoIGEgdmFsdWUgb3IgYG51bGxgLlwiKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdW5kZWZpbmVkRXJyb3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHVuZGVmaW5lZEVycm9yKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBlcnJvclxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7XG4gICAgICBnZXQ6ICgpID0+IGRhdGFcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZW1pdChhYm9ydGVkLCBzZXR0bGVkS2V5KSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcihhYm9ydGVkLCBzZXR0bGVkS2V5KSk7XG4gIH1cbiAgc3Vic2NyaWJlKGZuKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZm9yRWFjaCgodiwgaykgPT4gdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoaykpO1xuICAgIHRoaXMuZW1pdCh0cnVlKTtcbiAgfVxuICBhc3luYyByZXNvbHZlRGF0YShzaWduYWwpIHtcbiAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5kb25lKSB7XG4gICAgICBsZXQgb25BYm9ydCA9ICgpID0+IHRoaXMuY2FuY2VsKCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgYWJvcnRlZCA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZShhYm9ydGVkID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICAgIGlmIChhYm9ydGVkIHx8IHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShhYm9ydGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhYm9ydGVkO1xuICB9XG4gIGdldCBkb25lKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdLZXlzU2V0LnNpemUgPT09IDA7XG4gIH1cbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuZGF0YSAhPT0gbnVsbCAmJiB0aGlzLmRvbmUsIFwiQ2FuIG9ubHkgdW53cmFwIGRhdGEgb24gaW5pdGlhbGl6ZWQgYW5kIHNldHRsZWQgZGVmZXJyZWRzXCIpO1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmRhdGEpLnJlZHVjZSgoYWNjLCBfcmVmMikgPT4ge1xuICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYyO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgIFtrZXldOiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH0sIHt9KTtcbiAgfVxuICBnZXQgcGVuZGluZ0tleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nS2V5c1NldCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVHJhY2tlZFByb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB2YWx1ZS5fdHJhY2tlZCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVud3JhcFRyYWNrZWRQcm9taXNlKHZhbHVlKSB7XG4gIGlmICghaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlLl9lcnJvcikge1xuICAgIHRocm93IHZhbHVlLl9lcnJvcjtcbiAgfVxuICByZXR1cm4gdmFsdWUuX2RhdGE7XG59XG5jb25zdCBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGRhdGEsIGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSB7fTtcbiAgfVxuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgc3RhdHVzOiBpbml0XG4gIH0gOiBpbml0O1xuICByZXR1cm4gbmV3IERlZmVycmVkRGF0YShkYXRhLCByZXNwb25zZUluaXQpO1xufTtcbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZS4gU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmNvbnN0IHJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QodXJsLCBpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0gMzAyO1xuICB9XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgIHN0YXR1czogcmVzcG9uc2VJbml0XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCBfZXh0ZW5kcyh7fSwgcmVzcG9uc2VJbml0LCB7XG4gICAgaGVhZGVyc1xuICB9KSk7XG59O1xuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlIHRoYXQgd2lsbCBmb3JjZSBhIGRvY3VtZW50IHJlbG9hZCB0byB0aGUgbmV3IGxvY2F0aW9uLlxuICogU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmNvbnN0IHJlZGlyZWN0RG9jdW1lbnQgPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVXRpbGl0eSBjbGFzcyB3ZSB1c2UgdG8gaG9sZCBhdXRvLXVud3JhcHBlZCA0eHgvNXh4IFJlc3BvbnNlIGJvZGllc1xuICovXG5jbGFzcyBFcnJvclJlc3BvbnNlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSwgaW50ZXJuYWwpIHtcbiAgICBpZiAoaW50ZXJuYWwgPT09IHZvaWQgMCkge1xuICAgICAgaW50ZXJuYWwgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvd24gZnJvbSBhbiBhY3Rpb24vbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJiBcImRhdGFcIiBpbiBlcnJvcjtcbn1cblxuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIgPSBbXCJwb3N0XCIsIFwicHV0XCIsIFwicGF0Y2hcIiwgXCJkZWxldGVcIl07XG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQodmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIpO1xuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kc0FyciA9IFtcImdldFwiLCAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0Fycl07XG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldCh2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuY29uc3QgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzA3LCAzMDhdKTtcbmNvbnN0IElETEVfTkFWSUdBVElPTiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWRcbn07XG5jb25zdCBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWRcbn07XG5jb25zdCBJRExFX0JMT0NLRVIgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gIHJlc2V0OiB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWRcbn07XG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG5jb25zdCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzID0gcm91dGUgPT4gKHtcbiAgaGFzRXJyb3JCb3VuZGFyeTogQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KVxufSk7XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlUm91dGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBDcmVhdGUgYSByb3V0ZXIgYW5kIGxpc3RlbiB0byBoaXN0b3J5IFBPUCBuYXZpZ2F0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdCkge1xuICBjb25zdCByb3V0ZXJXaW5kb3cgPSBpbml0LndpbmRvdyA/IGluaXQud2luZG93IDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHJvdXRlcldpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgaXNTZXJ2ZXIgPSAhaXNCcm93c2VyO1xuICBpbnZhcmlhbnQoaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCwgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVSb3V0ZXJcIik7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGlmIChpbml0Lm1hcFJvdXRlUHJvcGVydGllcykge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGluaXQubWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9IGVsc2UgaWYgKGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gUm91dGVzIGtleWVkIGJ5IElEXG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICAvLyBSb3V0ZXMgaW4gdHJlZSBmb3JtYXQgZm9yIG1hdGNoaW5nXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhpbml0LnJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgbGV0IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgbGV0IGJhc2VuYW1lID0gaW5pdC5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X25vcm1hbGl6ZUZvcm1NZXRob2Q6IGZhbHNlLFxuICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogZmFsc2VcbiAgfSwgaW5pdC5mdXR1cmUpO1xuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBoaXN0b3J5XG4gIGxldCB1bmxpc3Rlbkhpc3RvcnkgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9ucyB0byBjYWxsIG9uIGFsbCBzdGF0ZSBjaGFuZ2VzXG4gIGxldCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBvYmplY3QgdG8gaG9sZCBzY3JvbGwgcmVzdG9yYXRpb24gbG9jYXRpb25zIGR1cmluZyByb3V0aW5nXG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCByZXN0b3JhdGlvbiBrZXlzXG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIC8vIE9uZS10aW1lIGZsYWcgdG8gY29udHJvbCB0aGUgaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLiAgQmVjYXVzZVxuICAvLyB3ZSBkb24ndCBnZXQgdGhlIHNhdmVkIHBvc2l0aW9ucyBmcm9tIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB1bnRpbCBfYWZ0ZXJfXG4gIC8vIHRoZSBpbml0aWFsIHJlbmRlciwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VwYXJhdGUgdXBkYXRlU3RhdGUgdG9cbiAgLy8gc2VuZCBhbG9uZyB0aGUgcmVzdG9yZVNjcm9sbFBvc2l0aW9uXG4gIC8vIFNldCB0byB0cnVlIGlmIHdlIGhhdmUgYGh5ZHJhdGlvbkRhdGFgIHNpbmNlIHdlIGFzc3VtZSB3ZSB3ZXJlIFNTUidkIGFuZCB0aGF0XG4gIC8vIFNTUiBkaWQgdGhlIGluaXRpYWwgc2Nyb2xsIHJlc3RvcmF0aW9uLlxuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xuICBsZXQgaW5pdGlhbEVycm9ycyA9IG51bGw7XG4gIGlmIChpbml0aWFsTWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IG1hdGNoIGEgdXNlci1wcm92aWRlZC1yb3V0ZSwgZmFsbCBiYWNrIHRvIHRoZSByb290XG4gICAgLy8gdG8gYWxsb3cgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHRha2Ugb3ZlclxuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICBwYXRobmFtZTogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICByb3V0ZVxuICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgIGluaXRpYWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBpbml0aWFsRXJyb3JzID0ge1xuICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICB9O1xuICB9XG4gIGxldCBpbml0aWFsaXplZCA9XG4gIC8vIEFsbCBpbml0aWFsTWF0Y2hlcyBuZWVkIHRvIGJlIGxvYWRlZCBiZWZvcmUgd2UncmUgcmVhZHkuICBJZiB3ZSBoYXZlIGxhenlcbiAgLy8gZnVuY3Rpb25zIGFyb3VuZCBzdGlsbCB0aGVuIHdlJ2xsIG5lZWQgdG8gcnVuIHRoZW0gaW4gaW5pdGlhbGl6ZSgpXG4gICFpbml0aWFsTWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5sYXp5KSAmJiAoXG4gIC8vIEFuZCB3ZSBoYXZlIHRvIGVpdGhlciBoYXZlIG5vIGxvYWRlcnMgb3IgaGF2ZSBiZWVuIHByb3ZpZGVkIGh5ZHJhdGlvbkRhdGFcbiAgIWluaXRpYWxNYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmxvYWRlcikgfHwgaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwpO1xuICBsZXQgcm91dGVyO1xuICBsZXQgc3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSB8fCBudWxsLFxuICAgIGVycm9yczogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKClcbiAgfTtcbiAgLy8gLS0gU3RhdGVmdWwgaW50ZXJuYWwgdmFyaWFibGVzIHRvIG1hbmFnZSBuYXZpZ2F0aW9ucyAtLVxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXG4gIGxldCBwZW5kaW5nQWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gcHJldmVudCB0aGUgc2Nyb2xsIHJlc2V0IGlmIHNjcm9sbCBjYW5ub3RcbiAgLy8gYmUgcmVzdG9yZWQ/XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gIC8vIEFib3J0Q29udHJvbGxlciBmb3IgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXI7XG4gIC8vIFdlIHVzZSB0aGlzIHRvIGF2b2lkIHRvdWNoaW5nIGhpc3RvcnkgaW4gY29tcGxldGVOYXZpZ2F0aW9uIGlmIGFcbiAgLy8gcmV2YWxpZGF0aW9uIGlzIGVudGlyZWx5IHVuaW50ZXJydXB0ZWRcbiAgbGV0IGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBmbGFnIHRvIGZvcmNlIHJldmFsaWRhdGlvbiBvZiBhbGwgbG9hZGVyczpcbiAgLy8gIC0gc3VibWlzc2lvbnMgKGNvbXBsZXRlZCBvciBpbnRlcnJ1cHRlZClcbiAgLy8gIC0gdXNlUmV2YWxpZGF0b3IoKVxuICAvLyAgLSBYLVJlbWl4LVJldmFsaWRhdGUgKGZyb20gcmVkaXJlY3QpXG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgcm91dGVzIHRoYXQgcmVxdWlyZSByZXZhbGlkYXRpb24gZHVlXG4gIC8vIHRvIGEgY2FuY2VsbGVkIGRlZmVycmVkIG9uIGFjdGlvbiBzdWJtaXNzaW9uXG4gIGxldCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyA9IFtdO1xuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIGZldGNoZXIgbG9hZHMgdGhhdCB3ZXJlIGNhbmNlbGxlZCBieSBhblxuICAvLyBhY3Rpb24gbmF2aWdhdGlvbiBhbmQgcmVxdWlyZSByZXZhbGlkYXRpb25cbiAgbGV0IGNhbmNlbGxlZEZldGNoZXJMb2FkcyA9IFtdO1xuICAvLyBBYm9ydENvbnRyb2xsZXJzIGZvciBhbnkgaW4tZmxpZ2h0IGZldGNoZXJzXG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBsb2FkcyBiYXNlZCBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBzdGFydGVkXG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICAvLyBUcmFjayB0aGUgb3V0c3RhbmRpbmcgcGVuZGluZyBuYXZpZ2F0aW9uIGRhdGEgbG9hZCB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XG4gIC8vIHRoZSBnbG9iYWxseSBpbmNyZW1lbnRpbmcgbG9hZCB3aGVuIGEgZmV0Y2hlciBsb2FkIGxhbmRzIGFmdGVyIGEgY29tcGxldGVkXG4gIC8vIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gIC8vIEZldGNoZXJzIHRoYXQgdHJpZ2dlcmVkIGRhdGEgcmVsb2FkcyBhcyBhIHJlc3VsdCBvZiB0aGVpciBhY3Rpb25zXG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IG5ldyBNYXAoKTtcbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgcmVkaXJlY3QgbmF2aWdhdGlvbnNcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSBuZXcgU2V0KCk7XG4gIC8vIE1vc3QgcmVjZW50IGhyZWYvbWF0Y2ggZm9yIGZldGNoZXIubG9hZCBjYWxscyBmb3IgZmV0Y2hlcnNcbiAgbGV0IGZldGNoTG9hZE1hdGNoZXMgPSBuZXcgTWFwKCk7XG4gIC8vIFN0b3JlIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgZm9yIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLiAgV2hlbiBhXG4gIC8vIHJvdXRlIGxvYWRlciByZXR1cm5zIGRlZmVyKCkgd2Ugc3RpY2sgb25lIGluIGhlcmUuICBUaGVuLCB3aGVuIGEgbmVzdGVkXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMgd2UgdXBkYXRlIGxvYWRlckRhdGEuICBJZiBhIG5ldyBuYXZpZ2F0aW9uIHN0YXJ0cyB3ZVxuICAvLyBjYW5jZWwgYWN0aXZlIGRlZmVycmVkcyBmb3IgZWxpbWluYXRlZCByb3V0ZXMuXG4gIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwKCk7XG4gIC8vIFN0b3JlIGJsb2NrZXIgZnVuY3Rpb25zIGluIGEgc2VwYXJhdGUgTWFwIG91dHNpZGUgb2Ygcm91dGVyIHN0YXRlIHNpbmNlXG4gIC8vIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIFVJIHN0YXRlIGlmIHRoZXkgY2hhbmdlXG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuICAvLyBGbGFnIHRvIGlnbm9yZSB0aGUgbmV4dCBoaXN0b3J5IHVwZGF0ZSwgc28gd2UgY2FuIHJldmVydCB0aGUgVVJMIGNoYW5nZSBvblxuICAvLyBhIFBPUCBuYXZpZ2F0aW9uIHRoYXQgd2FzIGJsb2NrZWQgYnkgdGhlIHVzZXIgd2l0aG91dCB0b3VjaGluZyByb3V0ZXIgc3RhdGVcbiAgbGV0IGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG4gIC8vIEluaXRpYWxpemUgdGhlIHJvdXRlciwgYWxsIHNpZGUgZWZmZWN0cyBzaG91bGQgYmUga2lja2VkIG9mZiBmcm9tIGhlcmUuXG4gIC8vIEltcGxlbWVudGVkIGFzIGEgRmx1ZW50IEFQSSBmb3IgZWFzZSBvZjpcbiAgLy8gICBsZXQgcm91dGVyID0gY3JlYXRlUm91dGVyKGluaXQpLmluaXRpYWxpemUoKTtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBJZiBoaXN0b3J5IGluZm9ybXMgdXMgb2YgYSBQT1AgbmF2aWdhdGlvbiwgc3RhcnQgdGhlIG5hdmlnYXRpb24gYnV0IGRvIG5vdCB1cGRhdGVcbiAgICAvLyBzdGF0ZS4gIFdlJ2xsIHVwZGF0ZSBvdXIgb3duIHN0YXRlIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGlvbjogaGlzdG9yeUFjdGlvbixcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIGRlbHRhXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIC8vIElnbm9yZSB0aGlzIGV2ZW50IGlmIGl0IHdhcyBqdXN0IHVzIHJlc2V0dGluZyB0aGUgVVJMIGZyb20gYVxuICAgICAgLy8gYmxvY2tlZCBQT1AgbmF2aWdhdGlvblxuICAgICAgaWYgKGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlKSB7XG4gICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsIFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgYmxvY2tlciBvbiBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gXCIgKyBcInRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbi4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbmF2aWdhdGluZyBvdXRzaWRlIHRoZSByb3V0ZXIgXCIgKyBcInZpYSBgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYC9gd2luZG93LmxvY2F0aW9uLmhhc2hgIGluc3RlYWQgb2YgdXNpbmcgXCIgKyBcInJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIFwiICsgXCJjcmVhdGVIYXNoUm91dGVyIGFuZCB0aGUgdXNlciBtYW51YWxseSBjaGFuZ2VzIHRoZSBVUkwuXCIpO1xuICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmIChibG9ja2VyS2V5ICYmIGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgVVJMIHRvIG1hdGNoIHRoZSBjdXJyZW50IFVJLCBidXQgZG9uJ3QgdXBkYXRlIHJvdXRlciBzdGF0ZVxuICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBsb2NhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZS1kbyB0aGUgc2FtZSBQT1AgbmF2aWdhdGlvbiB3ZSBqdXN0IGJsb2NrZWRcbiAgICAgICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgICAgIGJsb2NrZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICB9KTtcbiAgICAvLyBLaWNrIG9mZiBpbml0aWFsIGRhdGEgbG9hZCBpZiBuZWVkZWQuICBVc2UgUG9wIHRvIGF2b2lkIG1vZGlmeWluZyBoaXN0b3J5XG4gICAgLy8gTm90ZSB3ZSBkb24ndCBkbyBhbnkgaGFuZGxpbmcgb2YgbGF6eSBoZXJlLiAgRm9yIFNQQSdzIGl0J2xsIGdldCBoYW5kbGVkXG4gICAgLy8gaW4gdGhlIG5vcm1hbCBuYXZpZ2F0aW9uIGZsb3cuICBGb3IgU1NSIGl0J3MgZXhwZWN0ZWQgdGhhdCBsYXp5IG1vZHVsZXMgYXJlXG4gICAgLy8gcmVzb2x2ZWQgcHJpb3IgdG8gcm91dGVyIGNyZWF0aW9uIHNpbmNlIHdlIGNhbid0IGdvIGludG8gYSBmYWxsYmFja0VsZW1lbnRcbiAgICAvLyBVSSBmb3IgU1NSJ2QgYXBwc1xuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihBY3Rpb24uUG9wLCBzdGF0ZS5sb2NhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cbiAgLy8gU3Vic2NyaWJlIHRvIHN0YXRlIHVwZGF0ZXMgZm9yIHRoZSByb3V0ZXJcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZuKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICAvLyBVcGRhdGUgb3VyIHN0YXRlIGFuZCBub3RpZnkgdGhlIGNhbGxpbmcgY29udGV4dCBvZiB0aGUgY2hhbmdlXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIG5ld1N0YXRlKTtcbiAgICBzdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcihzdGF0ZSkpO1xuICB9XG4gIC8vIENvbXBsZXRlIGEgbmF2aWdhdGlvbiByZXR1cm5pbmcgdGhlIHN0YXRlLm5hdmlnYXRpb24gYmFjayB0byB0aGUgSURMRV9OQVZJR0FUSU9OXG4gIC8vIGFuZCBzZXR0aW5nIHN0YXRlLltoaXN0b3J5QWN0aW9uL2xvY2F0aW9uL21hdGNoZXNdIHRvIHRoZSBuZXcgcm91dGUuXG4gIC8vIC0gTG9jYXRpb24gaXMgYSByZXF1aXJlZCBwYXJhbVxuICAvLyAtIE5hdmlnYXRpb24gd2lsbCBhbHdheXMgYmUgc2V0IHRvIElETEVfTkFWSUdBVElPTlxuICAvLyAtIENhbiBwYXNzIGFueSBvdGhlciBzdGF0ZSBpbiBuZXdTdGF0ZVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIG5ld1N0YXRlKSB7XG4gICAgdmFyIF9sb2NhdGlvbiRzdGF0ZSwgX2xvY2F0aW9uJHN0YXRlMjtcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcbiAgICAvLyAtIFdlIGhhdmUgY29tbWl0dGVkIGFjdGlvbkRhdGEgaW4gdGhlIHN0b3JlXG4gICAgLy8gLSBUaGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcbiAgICAvLyAtIFRoZSBsb2NhdGlvbiBiZWluZyBsb2FkZWQgaXMgbm90IHRoZSByZXN1bHQgb2YgYSByZWRpcmVjdFxuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9IHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJiBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgKChfbG9jYXRpb24kc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2NhdGlvbiRzdGF0ZS5faXNSZWRpcmVjdCkgIT09IHRydWU7XG4gICAgbGV0IGFjdGlvbkRhdGE7XG4gICAgaWYgKG5ld1N0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW1wdHkgYWN0aW9uRGF0YSAtPiBjbGVhciBwcmlvciBhY3Rpb25EYXRhIGR1ZSB0byBhbiBhY3Rpb24gZXJyb3JcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FjdGlvblJlbG9hZCkge1xuICAgICAgLy8gS2VlcCB0aGUgY3VycmVudCBkYXRhIGlmIHdlJ3JlIHdyYXBwaW5nIHVwIHRoZSBhY3Rpb24gcmVsb2FkXG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXIgYWN0aW9uRGF0YSBvbiBhbnkgb3RoZXIgY29tcGxldGVkIG5hdmlnYXRpb25zXG4gICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQWx3YXlzIHByZXNlcnZlIGFueSBleGlzdGluZyBsb2FkZXJEYXRhIGZyb20gcmUtdXNlZCByb3V0ZXNcbiAgICBsZXQgbG9hZGVyRGF0YSA9IG5ld1N0YXRlLmxvYWRlckRhdGEgPyBtZXJnZUxvYWRlckRhdGEoc3RhdGUubG9hZGVyRGF0YSwgbmV3U3RhdGUubG9hZGVyRGF0YSwgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSwgbmV3U3RhdGUuZXJyb3JzKSA6IHN0YXRlLmxvYWRlckRhdGE7XG4gICAgLy8gT24gYSBzdWNjZXNzZnVsIG5hdmlnYXRpb24gd2UgY2FuIGFzc3VtZSB3ZSBnb3QgdGhyb3VnaCBhbGwgYmxvY2tlcnNcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcbiAgICBsZXQgYmxvY2tlcnMgPSBzdGF0ZS5ibG9ja2VycztcbiAgICBpZiAoYmxvY2tlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XG4gICAgICBibG9ja2Vycy5mb3JFYWNoKChfLCBrKSA9PiBibG9ja2Vycy5zZXQoaywgSURMRV9CTE9DS0VSKSk7XG4gICAgfVxuICAgIC8vIEFsd2F5cyByZXNwZWN0IHRoZSB1c2VyIGZsYWcuICBPdGhlcndpc2UgZG9uJ3QgcmVzZXQgb24gbXV0YXRpb25cbiAgICAvLyBzdWJtaXNzaW9uIG5hdmlnYXRpb25zIHVubGVzcyB0aGV5IHJlZGlyZWN0XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHwgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmICgoX2xvY2F0aW9uJHN0YXRlMiA9IGxvY2F0aW9uLnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2xvY2F0aW9uJHN0YXRlMi5faXNSZWRpcmVjdCkgIT09IHRydWU7XG4gICAgaWYgKGluRmxpZ2h0RGF0YVJvdXRlcykge1xuICAgICAgZGF0YVJvdXRlcyA9IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgOyBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUG9wKSA7IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5QdXNoKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gQWN0aW9uLlJlcGxhY2UpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHt9LCBuZXdTdGF0ZSwge1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcyksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2Vyc1xuICAgIH0pKTtcbiAgICAvLyBSZXNldCBzdGF0ZWZ1bCBuYXZpZ2F0aW9uIHZhcnNcbiAgICBwZW5kaW5nQWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgdG8sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnJvbVJvdXRlSWQsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVsYXRpdmUpO1xuICAgIGxldCB7XG4gICAgICBwYXRoLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGVycm9yXG4gICAgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhmdXR1cmUudjdfbm9ybWFsaXplRm9ybU1ldGhvZCwgZmFsc2UsIG5vcm1hbGl6ZWRQYXRoLCBvcHRzKTtcbiAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhdGUubG9jYXRpb247XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBwYXRoLCBvcHRzICYmIG9wdHMuc3RhdGUpO1xuICAgIC8vIFdoZW4gdXNpbmcgbmF2aWdhdGUgYXMgYSBQVVNIL1JFUExBQ0Ugd2UgYXJlbid0IHJlYWRpbmcgYW4gYWxyZWFkeS1lbmNvZGVkXG4gICAgLy8gVVJMIGZyb20gd2luZG93LmxvY2F0aW9uLCBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBoZXJlIHNvIHRoZSBiZWhhdmlvclxuICAgIC8vIHJlbWFpbnMgdGhlIHNhbWUgYXMgUE9QIGFuZCBub24tZGF0YS1yb3V0ZXIgdXNhZ2VzLiAgbmV3IFVSTCgpIGRvZXMgYWxsXG4gICAgLy8gdGhlIHNhbWUgZW5jb2Rpbmcgd2UnZCBnZXQgZnJvbSBhIGhpc3RvcnkucHVzaFN0YXRlL3dpbmRvdy5sb2NhdGlvbiByZWFkXG4gICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gdG91Y2ggaGlzdG9yeVxuICAgIG5leHRMb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBuZXh0TG9jYXRpb24sIGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbihuZXh0TG9jYXRpb24pKTtcbiAgICBsZXQgdXNlclJlcGxhY2UgPSBvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsID8gb3B0cy5yZXBsYWNlIDogdW5kZWZpbmVkO1xuICAgIGxldCBoaXN0b3J5QWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgaWYgKHVzZXJSZXBsYWNlID09PSB0cnVlKSB7XG4gICAgICBoaXN0b3J5QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIDsgZWxzZSBpZiAoc3VibWlzc2lvbiAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSAmJiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICAvLyBCeSBkZWZhdWx0IG9uIHN1Ym1pc3Npb25zIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIHdlIFJFUExBQ0Ugc28gdGhhdFxuICAgICAgLy8gdXNlcnMgZG9uJ3QgaGF2ZSB0byBkb3VibGUtY2xpY2sgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCB0byB0aGUgcHJpb3JcbiAgICAgIC8vIGxvY2F0aW9uLiAgSWYgdGhlIHVzZXIgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IGxvY2F0aW9uIGZyb20gdGhlXG4gICAgICAvLyBhY3Rpb24vbG9hZGVyIHRoaXMgd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgcmVkaXJlY3Qgd2lsbCBiZSBhIFBVU0hcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB9XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IG9wdHMgJiYgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiBpbiBvcHRzID8gb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pO1xuICAgIGlmIChibG9ja2VyS2V5KSB7XG4gICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNlbmQgdGhlIHNhbWUgbmF2aWdhdGlvbiB0aHJvdWdoXG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgICBibG9ja2Vyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBuZXh0TG9jYXRpb24sIHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAvLyBTZW5kIHRocm91Z2ggdGhlIGZvcm1EYXRhIHNlcmlhbGl6YXRpb24gZXJyb3IgaWYgd2UgaGF2ZSBvbmUgc28gd2UgY2FuXG4gICAgICAvLyByZW5kZXIgYXQgdGhlIHJpZ2h0IGVycm9yIGJvdW5kYXJ5IGFmdGVyIHdlIG1hdGNoIHJvdXRlc1xuICAgICAgcGVuZGluZ0Vycm9yOiBlcnJvcixcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlcGxhY2U6IG9wdHMgJiYgb3B0cy5yZXBsYWNlXG4gICAgfSk7XG4gIH1cbiAgLy8gUmV2YWxpZGF0ZSBhbGwgY3VycmVudCBsb2FkZXJzLiAgSWYgYSBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzIG9yIGlmIHRoaXNcbiAgLy8gaXMgaW50ZXJydXB0ZWQgYnkgYSBuYXZpZ2F0aW9uLCBhbGxvdyB0aGlzIHRvIFwic3VjY2VlZFwiIGJ5IGNhbGxpbmcgYWxsXG4gIC8vIGxvYWRlcnMgZHVyaW5nIHRoZSBuZXh0IGxvYWRlciByb3VuZFxuICBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgcmV2YWxpZGF0aW9uOiBcImxvYWRpbmdcIlxuICAgIH0pO1xuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBzdWJtaXR0aW5nIGFuIGFjdGlvbiwgd2UgZG9uJ3QgbmVlZCB0byBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24sIHdlJ2xsIGp1c3QgbGV0IHRoZSBmb2xsb3cgdXAgbG9hZGVyIGV4ZWN1dGlvbiBjYWxsIGFsbCBsb2FkZXJzXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbiBhbiBpZGxlIHN0YXRlLCBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uIGZvciB0aGUgY3VycmVudFxuICAgIC8vIGFjdGlvbi9sb2NhdGlvbiBhbmQgbWFyayBpdCBhcyB1bmludGVycnVwdGVkLCB3aGljaCB3aWxsIHNraXAgdGhlIGhpc3RvcnlcbiAgICAvLyB1cGRhdGUgaW4gY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oc3RhdGUuaGlzdG9yeUFjdGlvbiwgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSBjdXJyZW50bHkgaW4gYSBsb2FkaW5nIHN0YXRlLCBqdXN0IHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiB0byB0aGUgbmF2aWdhdGlvbi5sb2NhdGlvbiBidXQgZG8gbm90IHRyaWdnZXIgYW4gdW5pbnRlcnJ1cHRlZFxuICAgIC8vIHJldmFsaWRhdGlvbiBzbyB0aGF0IGhpc3RvcnkgY29ycmVjdGx5IHVwZGF0ZXMgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICBzdGFydE5hdmlnYXRpb24ocGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XG4gICAgICBvdmVycmlkZU5hdmlnYXRpb246IHN0YXRlLm5hdmlnYXRpb25cbiAgICB9KTtcbiAgfVxuICAvLyBTdGFydCBhIG5hdmlnYXRpb24gdG8gdGhlIGdpdmVuIGFjdGlvbi9sb2NhdGlvbi4gIENhbiBvcHRpb25hbGx5IHByb3ZpZGUgYVxuICAvLyBvdmVycmlkZU5hdmlnYXRpb24gd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgbm9ybWFsTG9hZCBpbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0XG4gIC8vIG5hdmlnYXRpb25cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBvcHRzKSB7XG4gICAgLy8gQWJvcnQgYW55IGluLXByb2dyZXNzIG5hdmlnYXRpb25zIGFuZCBzdGFydCBhIG5ldyBvbmUuIFVuc2V0IGFueSBvbmdvaW5nXG4gICAgLy8gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb25zIHVubGVzcyB0b2xkIG90aGVyd2lzZSwgc2luY2Ugd2Ugd2FudCB0aGlzXG4gICAgLy8gbmV3IG5hdmlnYXRpb24gdG8gdXBkYXRlIGhpc3Rvcnkgbm9ybWFsbHlcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBwZW5kaW5nQWN0aW9uID0gaGlzdG9yeUFjdGlvbjtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSAob3B0cyAmJiBvcHRzLnN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgPT09IHRydWU7XG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gZXZlcnkgdGltZSB3ZSBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uLFxuICAgIC8vIGFuZCB0cmFjayB3aGV0aGVyIHdlIHNob3VsZCByZXNldCBzY3JvbGwgb24gY29tcGxldGlvblxuICAgIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCB3aXRoIGEgNDA0IG9uIHRoZSByb290IGVycm9yIGJvdW5kYXJ5IGlmIHdlIG1hdGNoIG5vdGhpbmdcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgICBsZXQge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIHJvdXRlXG4gICAgICB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXNUb1VzZSk7XG4gICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgZGVmZXJyZWQgb24gNDA0cyBzaW5jZSB3ZSBkb24ndCBrZWVwIGFueSByb3V0ZXNcbiAgICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcygpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSByZXZhbGlkYXRpb24gb3JcbiAgICAvLyBtdXRhdGlvbiBzdWJtaXNzaW9uLlxuICAgIC8vXG4gICAgLy8gSWdub3JlIG9uIGluaXRpYWwgcGFnZSBsb2FkcyBiZWNhdXNlIHNpbmNlIHRoZSBpbml0aWFsIGxvYWQgd2lsbCBhbHdheXNcbiAgICAvLyBiZSBcInNhbWUgaGFzaFwiLiAgRm9yIGV4YW1wbGUsIG9uIC9wYWdlI2hhc2ggYW5kIHN1Ym1pdCBhIDxGb3JtIG1ldGhvZD1cInBvc3RcIj5cbiAgICAvLyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXG4gICAgaWYgKHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBjb250cm9sbGVyL1JlcXVlc3QgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgbG9jYXRpb24sIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwsIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgbGV0IHBlbmRpbmdFcnJvcjtcbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBlbmRpbmdFcnJvciwgaXQgbWVhbnMgdGhlIHVzZXIgYXR0ZW1wdGVkIGEgR0VUIHN1Ym1pc3Npb25cbiAgICAgIC8vIHdpdGggYmluYXJ5IEZvcm1EYXRhIHNvIGFzc2lnbiBoZXJlIGFuZCBza2lwIHRvIGhhbmRsZUxvYWRlcnMuICBUaGF0XG4gICAgICAvLyB3YXkgd2UgaGFuZGxlIGNhbGxpbmcgbG9hZGVycyBhYm92ZSB0aGUgYm91bmRhcnkgZXRjLiAgSXQncyBub3QgcmVhbGx5XG4gICAgICAvLyBkaWZmZXJlbnQgZnJvbSBhbiBhY3Rpb25FcnJvciBpbiB0aGF0IHNlbnNlLlxuICAgICAgcGVuZGluZ0Vycm9yID0ge1xuICAgICAgICBbZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzKS5yb3V0ZS5pZF06IG9wdHMucGVuZGluZ0Vycm9yXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIC8vIENhbGwgYWN0aW9uIGlmIHdlIHJlY2VpdmVkIGFuIGFjdGlvbiBzdWJtaXNzaW9uXG4gICAgICBsZXQgYWN0aW9uT3V0cHV0ID0gYXdhaXQgaGFuZGxlQWN0aW9uKHJlcXVlc3QsIGxvY2F0aW9uLCBvcHRzLnN1Ym1pc3Npb24sIG1hdGNoZXMsIHtcbiAgICAgICAgcmVwbGFjZTogb3B0cy5yZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICAgIC8vIENyZWF0ZSBhIEdFVCByZXF1ZXN0IGZvciB0aGUgbG9hZGVyc1xuICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDYWxsIGxvYWRlcnNcbiAgICBsZXQge1xuICAgICAgc2hvcnRDaXJjdWl0ZWQsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIGxvYWRpbmdOYXZpZ2F0aW9uLCBvcHRzICYmIG9wdHMuc3VibWlzc2lvbiwgb3B0cyAmJiBvcHRzLmZldGNoZXJTdWJtaXNzaW9uLCBvcHRzICYmIG9wdHMucmVwbGFjZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcik7XG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIG5vdyB0aGF0IHRoZSBhY3Rpb24vbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmXG4gICAgLy8gd2Ugc2hvcnQgY2lyY3VpdGVkIGJlY2F1c2UgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIHdpbGwgaGF2ZSBhbHJlYWR5XG4gICAgLy8gYmVlbiBhc3NpZ25lZCB0byBhIG5ldyBjb250cm9sbGVyIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIF9leHRlbmRzKHtcbiAgICAgIG1hdGNoZXNcbiAgICB9LCBwZW5kaW5nQWN0aW9uRGF0YSA/IHtcbiAgICAgIGFjdGlvbkRhdGE6IHBlbmRpbmdBY3Rpb25EYXRhXG4gICAgfSA6IHt9LCB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSkpO1xuICB9XG4gIC8vIENhbGwgdGhlIGFjdGlvbiBtYXRjaGVkIGJ5IHRoZSBsZWFmIHJvdXRlIGZvciB0aGlzIG5hdmlnYXRpb24gYW5kIGhhbmRsZVxuICAvLyByZWRpcmVjdHMvZXJyb3JzXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihyZXF1ZXN0LCBsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcywgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICAvLyBQdXQgdXMgaW4gYSBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IG5hdmlnYXRpb24gPSBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgbmF2aWdhdGlvblxuICAgIH0pO1xuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwiYWN0aW9uXCIsIHJlcXVlc3QsIGFjdGlvbk1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSk7XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZXBsYWNlO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZSA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRpZG4ndCBleHBsaWNpdHkgaW5kaWNhdGUgcmVwbGFjZSBiZWhhdmlvciwgcmVwbGFjZSBpZlxuICAgICAgICAvLyB3ZSByZWRpcmVjdGVkIHRvIHRoZSBleGFjdCBzYW1lIGxvY2F0aW9uIHdlJ3JlIGN1cnJlbnRseSBhdCB0byBhdm9pZFxuICAgICAgICAvLyBkb3VibGUgYmFjay1idXR0b25zXG4gICAgICAgIHJlcGxhY2UgPSByZXN1bHQubG9jYXRpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlc3VsdCwge1xuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICAvLyBCeSBkZWZhdWx0LCBhbGwgc3VibWlzc2lvbnMgYXJlIFJFUExBQ0UgbmF2aWdhdGlvbnMsIGJ1dCBpZiB0aGVcbiAgICAgIC8vIGFjdGlvbiB0aHJldyBhbiBlcnJvciB0aGF0J2xsIGJlIHJlbmRlcmVkIGluIGFuIGVycm9yRWxlbWVudCwgd2UgZmFsbFxuICAgICAgLy8gYmFjayB0byBQVVNIIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0aGUgYmFjayBidXR0b24gdG8gZ2V0IGJhY2sgdG9cbiAgICAgIC8vIHRoZSBwcmUtc3VibWlzc2lvbiBmb3JtIGxvY2F0aW9uIHRvIHRyeSBhZ2FpblxuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2VuZCBiYWNrIGFuIGVtcHR5IG9iamVjdCB3ZSBjYW4gdXNlIHRvIGNsZWFyIG91dCBhbnkgcHJpb3IgYWN0aW9uRGF0YVxuICAgICAgICBwZW5kaW5nQWN0aW9uRGF0YToge30sXG4gICAgICAgIHBlbmRpbmdBY3Rpb25FcnJvcjoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8vIENhbGwgYWxsIGFwcGxpY2FibGUgbG9hZGVycyBmb3IgdGhlIGdpdmVuIG1hdGNoZXMsIGhhbmRsaW5nIHJlZGlyZWN0cyxcbiAgLy8gZXJyb3JzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlcnMocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIG92ZXJyaWRlTmF2aWdhdGlvbiwgc3VibWlzc2lvbiwgZmV0Y2hlclN1Ym1pc3Npb24sIHJlcGxhY2UsIHBlbmRpbmdBY3Rpb25EYXRhLCBwZW5kaW5nRXJyb3IpIHtcbiAgICAvLyBGaWd1cmUgb3V0IHRoZSByaWdodCBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gdXNlIGZvciBkYXRhIGxvYWRpbmdcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvdmVycmlkZU5hdmlnYXRpb24gfHwgZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIC8vIElmIHRoaXMgd2FzIGEgcmVkaXJlY3QgZnJvbSBhbiBhY3Rpb24gd2UgZG9uJ3QgaGF2ZSBhIFwic3VibWlzc2lvblwiIGJ1dFxuICAgIC8vIHdlIGhhdmUgaXQgb24gdGhlIGxvYWRpbmcgbmF2aWdhdGlvbiBzbyB1c2UgdGhhdCBpZiBhdmFpbGFibGVcbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb24gfHwgZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKGxvYWRpbmdOYXZpZ2F0aW9uKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoaW5pdC5oaXN0b3J5LCBzdGF0ZSwgbWF0Y2hlcywgYWN0aXZlU3VibWlzc2lvbiwgbG9jYXRpb24sIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcik7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhyb3V0ZUlkID0+ICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHwgbWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgIGVycm9yczogcGVuZGluZ0Vycm9yIHx8IG51bGxcbiAgICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgICBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YVxuICAgICAgfSA6IHt9LCB1cGRhdGVkRmV0Y2hlcnMgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiwgd2UgcmVtYWluIGluIG91ciBjdXJyZW50IGlkbGVcbiAgICAvLyBzdGF0ZS4gIElmIG5vdCwgd2UgbmVlZCB0byBzd2l0Y2ggdG8gb3VyIGxvYWRpbmcgc3RhdGUgYW5kIGxvYWQgZGF0YSxcbiAgICAvLyBwcmVzZXJ2aW5nIGFueSBuZXcgYWN0aW9uIGRhdGEgb3IgZXhpc3RpbmcgYWN0aW9uIGRhdGEgKGluIHRoZSBjYXNlIG9mXG4gICAgLy8gYSByZXZhbGlkYXRpb24gaW50ZXJydXB0aW5nIGFuIGFjdGlvblJlbG9hZClcbiAgICBpZiAoIWlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIodW5kZWZpbmVkLCBmZXRjaGVyID8gZmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICB9KTtcbiAgICAgIGxldCBhY3Rpb25EYXRhID0gcGVuZGluZ0FjdGlvbkRhdGEgfHwgc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHtcbiAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb25cbiAgICAgIH0sIGFjdGlvbkRhdGEgPyBPYmplY3Qua2V5cyhhY3Rpb25EYXRhKS5sZW5ndGggPT09IDAgPyB7XG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGxcbiAgICAgIH0gOiB7XG4gICAgICAgIGFjdGlvbkRhdGFcbiAgICAgIH0gOiB7fSwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9IDoge30pKTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMocmYua2V5KSkge1xuICAgICAgICBhYm9ydEZldGNoZXIocmYua2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZi5jb250cm9sbGVyKSB7XG4gICAgICAgIC8vIEZldGNoZXJzIHVzZSBhbiBpbmRlcGVuZGVudCBBYm9ydENvbnRyb2xsZXIgc28gdGhhdCBhYm9ydGluZyBhIGZldGNoZXJcbiAgICAgICAgLy8gKHZpYSBkZWxldGVGZXRjaGVyKSBkb2VzIG5vdCBhYm9ydCB0aGUgdHJpZ2dlcmluZyBuYXZpZ2F0aW9uIHRoYXRcbiAgICAgICAgLy8gdHJpZ2dlcmVkIHRoZSByZXZhbGlkYXRpb25cbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBQcm94eSBuYXZpZ2F0aW9uIGFib3J0IHRocm91Z2ggdG8gcmV2YWxpZGF0aW9uIGZldGNoZXJzXG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goZiA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgcmVzdWx0cyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH0gPSBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoc3RhdGUubWF0Y2hlcywgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIHJlcXVlc3QpO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgX2FmdGVyXyBsb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWYgd2Ugc2hvcnRcbiAgICAvLyBjaXJjdWl0ZWQgYmVjYXVzZSBmZXRjaENvbnRyb2xsZXJzIHdvdWxkIGhhdmUgYmVlbiBhYm9ydGVkIGFuZFxuICAgIC8vIHJlYXNzaWduZWQgdG8gbmV3IGNvbnRyb2xsZXJzIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zKTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcbiAgICAvLyBJZiBhbnkgbG9hZGVycyByZXR1cm5lZCBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBpZiAocmVkaXJlY3QuaWR4ID49IG1hdGNoZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxuICAgICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxuICAgICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xuICAgICAgICBsZXQgZmV0Y2hlcktleSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW3JlZGlyZWN0LmlkeCAtIG1hdGNoZXNUb0xvYWQubGVuZ3RoXS5rZXk7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGZldGNoZXJLZXkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlZGlyZWN0LnJlc3VsdCwge1xuICAgICAgICByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCBwZW5kaW5nRXJyb3IsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKTtcbiAgICAvLyBXaXJlIHVwIHN1YnNjcmliZXJzIHRvIHVwZGF0ZSBsb2FkZXJEYXRhIGFzIHByb21pc2VzIHNldHRsZVxuICAgIGFjdGl2ZURlZmVycmVkcy5mb3JFYWNoKChkZWZlcnJlZERhdGEsIHJvdXRlSWQpID0+IHtcbiAgICAgIGRlZmVycmVkRGF0YS5zdWJzY3JpYmUoYWJvcnRlZCA9PiB7XG4gICAgICAgIC8vIE5vdGU6IE5vIG5lZWQgdG8gdXBkYXRlU3RhdGUgaGVyZSBzaW5jZSB0aGUgVHJhY2tlZFByb21pc2Ugb25cbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpcyBzdGFibGUgYWNyb3NzIHJlc29sdmUvcmVqZWN0XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGluc3RhbmNlIGlmIHdlIHdlcmUgYWJvcnRlZCBvciBpZiBwcm9taXNlcyBoYXZlIHNldHRsZWRcbiAgICAgICAgaWYgKGFib3J0ZWQgfHwgZGVmZXJyZWREYXRhLmRvbmUpIHtcbiAgICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG4gICAgbGV0IHNob3VsZFVwZGF0ZUZldGNoZXJzID0gdXBkYXRlZEZldGNoZXJzIHx8IGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSwgc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPyB7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9IDoge30pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuICAvLyBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pdCBmb3IgdGhlIGdpdmVuIGZldGNoZXIga2V5XG4gIGZ1bmN0aW9uIGZldGNoKGtleSwgcm91dGVJZCwgaHJlZiwgb3B0cykge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicm91dGVyLmZldGNoKCkgd2FzIGNhbGxlZCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIsIGJ1dCBpdCBzaG91bGRuJ3QgYmUuIFwiICsgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgKyBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIik7XG4gICAgfVxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcywgYmFzZW5hbWUsIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsIGhyZWYsIHJvdXRlSWQsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVsYXRpdmUpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoLCBiYXNlbmFtZSk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbm9ybWFsaXplZFBhdGhcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZXJyb3JcbiAgICB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLCB0cnVlLCBub3JtYWxpemVkUGF0aCwgb3B0cyk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdG9yZSBvZmYgdGhlIG1hdGNoIHNvIHdlIGNhbiBjYWxsIGl0J3Mgc2hvdWxkUmV2YWxpZGF0ZSBvbiBzdWJzZXF1ZW50XG4gICAgLy8gcmV2YWxpZGF0aW9uc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgICBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG4gIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIG1hdGNoZWQgZmV0Y2hlci5zdWJtaXQoKSwgYW5kIHRoZW4gaGFuZGxlIHJlZGlyZWN0cyxcbiAgLy8gZXJyb3JzLCBhbmQgcmV2YWxpZGF0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgcmVxdWVzdE1hdGNoZXMsIHN1Ym1pc3Npb24pIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIW1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgcm91dGVJZDogcm91dGVJZFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFB1dCB0aGlzIGZldGNoZXIgaW50byBpdCdzIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXIgPSBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpO1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIHBhdGgsIGFib3J0Q29udHJvbGxlci5zaWduYWwsIHN1Ym1pc3Npb24pO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcImFjdGlvblwiLCBmZXRjaFJlcXVlc3QsIG1hdGNoLCByZXF1ZXN0TWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUpO1xuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdSBvdXIgb3duIGZldGNoZXJcbiAgICAgIC8vIHJlLXN1Ym1pdCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGFjdGlvbiBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgIC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHJlZGlyZWN0IG5hdmlnYXRpb24uICBXZSBhbHJlYWR5XG4gICAgICAgIC8vIHNldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHNvIGFsbCBsb2FkZXJzIGZvciB0aGUgbmV3IHJvdXRlIHNob3VsZFxuICAgICAgICAvLyBmaXJlIHVubGVzcyBvcHRlZCBvdXQgdmlhIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICBsZXQgbG9hZGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZGluZ0ZldGNoZXIpO1xuICAgICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIGFjdGlvblJlc3VsdCwge1xuICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFueSBub24tcmVkaXJlY3QgZXJyb3JzIHRocm93blxuICAgIGlmIChpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTdGFydCB0aGUgZGF0YSBsb2FkIGZvciBjdXJyZW50IG1hdGNoZXMsIG9yIHRoZSBuZXh0IGxvY2F0aW9uIGlmIHdlJ3JlXG4gICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhIG5hdmlnYXRpb25cbiAgICBsZXQgbmV4dExvY2F0aW9uID0gc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiB8fCBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgcmV2YWxpZGF0aW9uUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgbmV4dExvY2F0aW9uLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9IHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgIT09IFwiaWRsZVwiID8gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIGJhc2VuYW1lKSA6IHN0YXRlLm1hdGNoZXM7XG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG4gICAgbGV0IGxvYWRGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgYWN0aW9uUmVzdWx0LmRhdGEpO1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoaW5pdC5oaXN0b3J5LCBzdGF0ZSwgbWF0Y2hlcywgc3VibWlzc2lvbiwgbmV4dExvY2F0aW9uLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHtcbiAgICAgIFttYXRjaC5yb3V0ZS5pZF06IGFjdGlvblJlc3VsdC5kYXRhXG4gICAgfSwgdW5kZWZpbmVkIC8vIE5vIG5lZWQgdG8gc2VuZCB0aHJvdWdoIGVycm9ycyBzaW5jZSB3ZSBzaG9ydCBjaXJjdWl0IGFib3ZlXG4gICAgKTtcbiAgICAvLyBQdXQgYWxsIHJldmFsaWRhdGluZyBmZXRjaGVycyBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlLCBleGNlcHQgZm9yIHRoZVxuICAgIC8vIGN1cnJlbnQgZmV0Y2hlciB3aGljaCB3ZSB3YW50IHRvIGtlZXAgaW4gaXQncyBjdXJyZW50IGxvYWRpbmcgc3RhdGUgd2hpY2hcbiAgICAvLyBjb250YWlucyBpdCdzIGFjdGlvbiBzdWJtaXNzaW9uIGluZm8gKyBhY3Rpb24gZGF0YVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZpbHRlcihyZiA9PiByZi5rZXkgIT09IGtleSkuZm9yRWFjaChyZiA9PiB7XG4gICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIodW5kZWZpbmVkLCBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHN0YWxlS2V5KSkge1xuICAgICAgICBhYm9ydEZldGNoZXIoc3RhbGVLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIGxldCB7XG4gICAgICByZXN1bHRzLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShzdGF0ZS5tYXRjaGVzLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVycywgcmV2YWxpZGF0aW9uUmVxdWVzdCk7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHIua2V5KSk7XG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgaWYgKHJlZGlyZWN0LmlkeCA+PSBtYXRjaGVzVG9Mb2FkLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJlZGlyZWN0IGNhbWUgZnJvbSBhIGZldGNoZXIgbWFrZSBzdXJlIHdlIG1hcmsgaXQgaW5cbiAgICAgICAgLy8gZmV0Y2hSZWRpcmVjdElkcyBzbyBpdCBkb2Vzbid0IGdldCByZXZhbGlkYXRlZCBvbiB0aGUgbmV4dCBzZXQgb2ZcbiAgICAgICAgLy8gbG9hZGVyIGV4ZWN1dGlvbnNcbiAgICAgICAgbGV0IGZldGNoZXJLZXkgPSByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QucmVzdWx0KTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQge1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgc3RhdGUubWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgbG9hZGVyUmVzdWx0cywgdW5kZWZpbmVkLCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMsIGFjdGl2ZURlZmVycmVkcyk7XG4gICAgLy8gU2luY2Ugd2UgbGV0IHJldmFsaWRhdGlvbnMgY29tcGxldGUgZXZlbiBpZiB0aGUgc3VibWl0dGluZyBmZXRjaGVyIHdhc1xuICAgIC8vIGRlbGV0ZWQsIG9ubHkgcHV0IGl0IGJhY2sgdG8gaWRsZSBpZiBpdCBoYXNuJ3QgYmVlbiBkZWxldGVkXG4gICAgaWYgKHN0YXRlLmZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW4gYSBuYXZpZ2F0aW9uIGxvYWRpbmcgc3RhdGUgYW5kIHRoaXMgZmV0Y2hlciBpc1xuICAgIC8vIG1vcmUgcmVjZW50IHRoYW4gdGhlIG5hdmlnYXRpb24sIHdlIHdhbnQgdGhlIG5ld2VyIGRhdGEgc28gYWJvcnQgdGhlXG4gICAgLy8gbmF2aWdhdGlvbiBhbmQgY29tcGxldGUgaXQgd2l0aCB0aGUgZmV0Y2hlciBkYXRhXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKSB7XG4gICAgICBpbnZhcmlhbnQocGVuZGluZ0FjdGlvbiwgXCJFeHBlY3RlZCBwZW5kaW5nIGFjdGlvblwiKTtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXBkYXRlIHdpdGggdGhlIGZldGNoZXIgZGF0YSwgcHJlc2VydmluZyBhbnkgZXhpc3RpbmdcbiAgICAgIC8vIGxvYWRlckRhdGEgZm9yIGxvYWRlcnMgdGhhdCBkaWQgbm90IG5lZWQgdG8gcmVsb2FkLiAgV2UgaGF2ZSB0b1xuICAgICAgLy8gbWFudWFsbHkgbWVyZ2UgaGVyZSBzaW5jZSB3ZSBhcmVuJ3QgZ29pbmcgdGhyb3VnaCBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoc3RhdGUubG9hZGVyRGF0YSwgbG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKVxuICAgICAgfSwgZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDAgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENhbGwgdGhlIG1hdGNoZWQgbG9hZGVyIGZvciBmZXRjaGVyLmxvYWQoKSwgaGFuZGxpbmcgcmVkaXJlY3RzLCBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIC8vIFB1dCB0aGlzIGZldGNoZXIgaW50byBpdCdzIGxvYWRpbmcgc3RhdGVcbiAgICBsZXQgbG9hZGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZGluZ0ZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIC8vIENhbGwgdGhlIGxvYWRlciBmb3IgdGhpcyBmZXRjaGVyIHJvdXRlIG1hdGNoXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBwYXRoLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgZmV0Y2hSZXF1ZXN0LCBtYXRjaCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUpO1xuICAgIC8vIERlZmVycmVkIGlzbid0IHN1cHBvcnRlZCBmb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fCByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdXIgb3VyIG93biBmZXRjaGVyXG4gICAgLy8gcmUtbG9hZCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHRoZSBsb2FkZXIgdGhyZXcgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgLy8gQSBuZXcgbmF2aWdhdGlvbiB3YXMga2lja2VkIG9mZiBhZnRlciBvdXIgbG9hZGVyIHN0YXJ0ZWQsIHNvIHRoYXRcbiAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvblxuICAgICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICAvLyBUT0RPOiBJbiByZW1peCwgdGhpcyB3b3VsZCByZXNldCB0byBJRExFX05BVklHQVRJT04gaWYgaXQgd2FzIGEgY2F0Y2ggLVxuICAgICAgLy8gZG8gd2UgbmVlZCB0byBiZWhhdmUgYW55IGRpZmZlcmVudGx5IHdpdGggb3VyIG5vbi1yZWRpcmVjdCBlcnJvcnM/XG4gICAgICAvLyBXaGF0IGlmIGl0IHdhcyBhIG5vbi1yZWRpcmVjdCBSZXNwb25zZT9cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICAvLyBQdXQgdGhlIGZldGNoZXIgYmFjayBpbnRvIGFuIGlkbGUgc3RhdGVcbiAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGhhbmRsZSByZWRpcmVjdHMgcmV0dXJuZWQgZnJvbSBhbiBhY3Rpb24gb3IgbG9hZGVyLlxuICAgKiBOb3JtYWxseSwgYSByZWRpcmVjdCBcInJlcGxhY2VzXCIgdGhlIG5hdmlnYXRpb24gdGhhdCB0cmlnZ2VyZWQgaXQuICBTbywgZm9yXG4gICAqIGV4YW1wbGU6XG4gICAqXG4gICAqICAtIHVzZXIgaXMgb24gL2FcbiAgICogIC0gdXNlciBjbGlja3MgYSBsaW5rIHRvIC9iXG4gICAqICAtIGxvYWRlciBmb3IgL2IgcmVkaXJlY3RzIHRvIC9jXG4gICAqXG4gICAqIEluIGEgbm9uLUpTIGFwcCB0aGUgYnJvd3NlciB3b3VsZCB0cmFjayB0aGUgaW4tZmxpZ2h0IG5hdmlnYXRpb24gdG8gL2IgYW5kXG4gICAqIHRoZW4gcmVwbGFjZSBpdCB3aXRoIC9jIHdoZW4gaXQgZW5jb3VudGVyZWQgdGhlIHJlZGlyZWN0IHJlc3BvbnNlLiAgSW5cbiAgICogdGhlIGVuZCBpdCB3b3VsZCBvbmx5IGV2ZXIgdXBkYXRlIHRoZSBVUkwgYmFyIHdpdGggL2MuXG4gICAqXG4gICAqIEluIGNsaWVudC1zaWRlIHJvdXRpbmcgdXNpbmcgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSwgd2UgYWltIHRvIGVtdWxhdGVcbiAgICogdGhpcyBiZWhhdmlvciBhbmQgd2UgYWxzbyBkbyBub3QgdXBkYXRlIGhpc3RvcnkgdW50aWwgdGhlIGVuZCBvZiB0aGVcbiAgICogbmF2aWdhdGlvbiAoaW5jbHVkaW5nIHByb2Nlc3NlZCByZWRpcmVjdHMpLiAgVGhpcyBtZWFucyB0aGF0IHdlIG5ldmVyXG4gICAqIGFjdHVhbGx5IHRvdWNoIGhpc3RvcnkgdW50aWwgd2UndmUgcHJvY2Vzc2VkIHJlZGlyZWN0cywgc28gd2UganVzdCB1c2VcbiAgICogdGhlIGhpc3RvcnkgYWN0aW9uIGZyb20gdGhlIG9yaWdpbmFsIG5hdmlnYXRpb24gKFBVU0ggb3IgUkVQTEFDRSkuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QsIF90ZW1wKSB7XG4gICAgbGV0IHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICAgIHJlcGxhY2VcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgaWYgKHJlZGlyZWN0LnJldmFsaWRhdGUpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCByZWRpcmVjdC5sb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpbnZhcmlhbnQocmVkaXJlY3RMb2NhdGlvbiwgXCJFeHBlY3RlZCBhIGxvY2F0aW9uIG9uIHRoZSByZWRpcmVjdCBuYXZpZ2F0aW9uXCIpO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG4gICAgICBpZiAocmVkaXJlY3QucmVsb2FkRG9jdW1lbnQpIHtcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5lZCBYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QocmVkaXJlY3QubG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID1cbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHxcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0SGlzdG9yeUFjdGlvbiA9IHJlcGxhY2UgPT09IHRydWUgPyBBY3Rpb24uUmVwbGFjZSA6IEFjdGlvbi5QdXNoO1xuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGVcbiAgICB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3Quc3RhdHVzKSAmJiBhY3RpdmVTdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiBfZXh0ZW5kcyh7fSwgYWN0aXZlU3VibWlzc2lvbiwge1xuICAgICAgICAgIGZvcm1BY3Rpb246IHJlZGlyZWN0LmxvY2F0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGlzIGZsYWcgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXG4gICAgICAvLyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24ocmVkaXJlY3RMb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShjdXJyZW50TWF0Y2hlcywgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICAvLyBDYWxsIGFsbCBuYXZpZ2F0aW9uIGxvYWRlcnMgYW5kIHJldmFsaWRhdGluZyBmZXRjaGVyIGxvYWRlcnMgaW4gcGFyYWxsZWwsXG4gICAgLy8gdGhlbiBzbGljZSBvZmYgdGhlIHJlc3VsdHMgaW50byBzZXBhcmF0ZSBhcnJheXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtXG4gICAgLy8gYWNjb3JkaW5nbHlcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi5tYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lKSksIC4uLmZldGNoZXJzVG9Mb2FkLm1hcChmID0+IHtcbiAgICAgIGlmIChmLm1hdGNoZXMgJiYgZi5tYXRjaCAmJiBmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxMb2FkZXJPckFjdGlvbihcImxvYWRlclwiLCBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIGYucGF0aCwgZi5jb250cm9sbGVyLnNpZ25hbCksIGYubWF0Y2gsIGYubWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVycm9yID0ge1xuICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgICAgICBwYXRobmFtZTogZi5wYXRoXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH0pXSk7XG4gICAgbGV0IGxvYWRlclJlc3VsdHMgPSByZXN1bHRzLnNsaWNlKDAsIG1hdGNoZXNUb0xvYWQubGVuZ3RoKTtcbiAgICBsZXQgZmV0Y2hlclJlc3VsdHMgPSByZXN1bHRzLnNsaWNlKG1hdGNoZXNUb0xvYWQubGVuZ3RoKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhjdXJyZW50TWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgbG9hZGVyUmVzdWx0cywgbG9hZGVyUmVzdWx0cy5tYXAoKCkgPT4gcmVxdWVzdC5zaWduYWwpLCBmYWxzZSwgc3RhdGUubG9hZGVyRGF0YSksIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoY3VycmVudE1hdGNoZXMsIGZldGNoZXJzVG9Mb2FkLm1hcChmID0+IGYubWF0Y2gpLCBmZXRjaGVyUmVzdWx0cywgZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4gZi5jb250cm9sbGVyID8gZi5jb250cm9sbGVyLnNpZ25hbCA6IG51bGwpLCB0cnVlKV0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHRzLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpIHtcbiAgICAvLyBFdmVyeSBpbnRlcnJ1cHRpb24gdHJpZ2dlcnMgYSByZXZhbGlkYXRpb25cbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICAvLyBDYW5jZWwgcGVuZGluZyByb3V0ZS1sZXZlbCBkZWZlcnJlZHMgYW5kIG1hcmsgY2FuY2VsbGVkIHJvdXRlcyBmb3JcbiAgICAvLyByZXZhbGlkYXRpb25cbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5wdXNoKC4uLmNhbmNlbEFjdGl2ZURlZmVycmVkcygpKTtcbiAgICAvLyBBYm9ydCBpbi1mbGlnaHQgZmV0Y2hlciBsb2Fkc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkge1xuICAgICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMucHVzaChrZXkpO1xuICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvcikge1xuICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCByb3V0ZUlkKTtcbiAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZXJyb3JzOiB7XG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3JcbiAgICAgIH0sXG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleSkge1xuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgLy8gRG9uJ3QgYWJvcnQgdGhlIGNvbnRyb2xsZXIgaWYgdGhpcyBpcyBhIGRlbGV0aW9uIG9mIGEgZmV0Y2hlci5zdWJtaXQoKVxuICAgIC8vIGluIGl0J3MgbG9hZGluZyBwaGFzZSBzaW5jZSAtIHdlIGRvbid0IHdhbnQgdG8gYWJvcnQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAvLyByZXZhbGlkYXRpb24gYW5kIHdhbnQgdGhlbSB0byBjb21wbGV0ZSBhbmQgbGFuZFxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpICYmICEoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBmZXRjaFJlbG9hZElkcy5oYXMoa2V5KSkpIHtcbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleSkge1xuICAgIGxldCBjb250cm9sbGVyID0gZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KTtcbiAgICBpbnZhcmlhbnQoY29udHJvbGxlciwgXCJFeHBlY3RlZCBmZXRjaCBjb250cm9sbGVyOiBcIiArIGtleSk7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gbWFya0ZldGNoZXJzRG9uZShrZXlzKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIoZmV0Y2hlci5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpIHtcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGZldGNoUmVkaXJlY3RJZHMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgXCJFeHBlY3RlZCBmZXRjaGVyOiBcIiArIGtleSk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB1cGRhdGVkRmV0Y2hlcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgICByZXR1cm4gdXBkYXRlZEZldGNoZXJzO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkKSB7XG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBcIkV4cGVjdGVkIGZldGNoZXI6IFwiICsga2V5KTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJsb2NrZXIoa2V5LCBmbikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLmdldChrZXkpICE9PSBmbikge1xuICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zZXQoa2V5LCBmbik7XG4gICAgfVxuICAgIHJldHVybiBibG9ja2VyO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5KSB7XG4gICAgc3RhdGUuYmxvY2tlcnMuZGVsZXRlKGtleSk7XG4gICAgYmxvY2tlckZ1bmN0aW9ucy5kZWxldGUoa2V5KTtcbiAgfVxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHVwZGF0ZSBibG9ja2VycywgZW5zdXJpbmcgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnNcbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlcihrZXksIG5ld0Jsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICAvLyBQb29yIG1hbnMgc3RhdGUgbWFjaGluZSA6KVxuICAgIC8vIGh0dHBzOi8vbWVybWFpZC5saXZlL2VkaXQjcGFrbzplTnFWa2M5T3d6QU14bDhsOG5uakFZckV0RElPSEVCSWd3dktKVFJlR3kzX2xEcElxTzI3azZhd01HMFhjckxsbno4N253ZG9uRVNvZ0tYWEJ1RTc5cnE3NVhaTzMteUhkczBSSlZ1djcwWXJQbFVyQ0VlMkhmck9SUzNydWJxWmZ1aHRwZzVDOXdrNXRaNFZLY1JVcTg4cTlaOFJTMC00OGNFMWlISmtMMHVnYkh1Rkx1czlMNnNwWnk4blg5TVAyQ05kb21WYXBvc3F1M2ZHYXlUOFQ4LWpKUXdoZXBvX1V0cGdCUWFERVVvbTA0ZFpoQU4xYUpCRGxVS0pCeEUxY2VCMlNtajBNbG4tSUJXNUFGVTJkd1Vpa3R0XzJRYXEyZEJmYUtkRXVwODVVVjdZZC1kS2psbmthYmwyUHZyMERUa1RyZU1cbiAgICBpbnZhcmlhbnQoYmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIsIFwiSW52YWxpZCBibG9ja2VyIHN0YXRlIHRyYW5zaXRpb246IFwiICsgYmxvY2tlci5zdGF0ZSArIFwiIC0+IFwiICsgbmV3QmxvY2tlci5zdGF0ZSk7XG4gICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgYmxvY2tlcnMuc2V0KGtleSwgbmV3QmxvY2tlcik7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgYmxvY2tlcnNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRCbG9ja05hdmlnYXRpb24oX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIG9ueSBzdXBwb3J0IGEgc2luZ2xlIGFjdGl2ZSBibG9ja2VyIGF0IHRoZSBtb21lbnQgc2luY2Ugd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIGFueSBjb21wZWxsaW5nIHVzZSBjYXNlcyBmb3IgbXVsdGktYmxvY2tlciB5ZXRcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID4gMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJBIHJvdXRlciBvbmx5IHN1cHBvcnRzIG9uZSBibG9ja2VyIGF0IGEgdGltZVwiKTtcbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG4gICAgaWYgKGJsb2NrZXIgJiYgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHtcbiAgICAgIC8vIElmIHRoZSBibG9ja2VyIGlzIGN1cnJlbnRseSBwcm9jZWVkaW5nLCB3ZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrXG4gICAgICAvLyBpdCBhbmQgY2FuIGxldCB0aGlzIG5hdmlnYXRpb24gY29udGludWVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2Uga25vdyB3ZSdyZSB1bmJsb2NrZWQvYmxvY2tlZCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZVxuICAgIC8vIHVzZXItcHJvdmlkZWQgYmxvY2tlciBmdW5jdGlvblxuICAgIGlmIChibG9ja2VyRnVuY3Rpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcktleTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsQWN0aXZlRGVmZXJyZWRzKHByZWRpY2F0ZSkge1xuICAgIGxldCBjYW5jZWxsZWRSb3V0ZUlkcyA9IFtdO1xuICAgIGFjdGl2ZURlZmVycmVkcy5mb3JFYWNoKChkZmQsIHJvdXRlSWQpID0+IHtcbiAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShyb3V0ZUlkKSkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlZmVycmVkIC0gYnV0IGRvIG5vdCByZW1vdmUgZnJvbSBhY3RpdmVEZWZlcnJlZHMgaGVyZSAtXG4gICAgICAgIC8vIHdlIHJlbHkgb24gdGhlIHN1YnNjcmliZXJzIHRvIGRvIHRoYXQgc28gb3VyIHRlc3RzIGNhbiBhc3NlcnQgcHJvcGVyXG4gICAgICAgIC8vIGNsZWFudXAgdmlhIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkc1xuICAgICAgICBkZmQuY2FuY2VsKCk7XG4gICAgICAgIGNhbmNlbGxlZFJvdXRlSWRzLnB1c2gocm91dGVJZCk7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5kZWxldGUocm91dGVJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbmNlbGxlZFJvdXRlSWRzO1xuICB9XG4gIC8vIE9wdCBpbiB0byBjYXB0dXJpbmcgYW5kIHJlcG9ydGluZyBzY3JvbGwgcG9zaXRpb25zIGR1cmluZyBuYXZpZ2F0aW9ucyxcbiAgLy8gdXNlZCBieSB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24ocG9zaXRpb25zLCBnZXRQb3NpdGlvbiwgZ2V0S2V5KSB7XG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcbiAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IGdldEtleSB8fCBudWxsO1xuICAgIC8vIFBlcmZvcm0gaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLCBzaW5jZSB3ZSBtaXNzIHRoZSBib2F0IG9uXG4gICAgLy8gdGhlIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBiZWNhdXNlIHdlJ3ZlIG5vdCB5ZXQgcmVuZGVyZWQgPFNjcm9sbFJlc3RvcmF0aW9uLz5cbiAgICAvLyBhbmQgdGhlcmVmb3JlIGhhdmUgbm8gc2F2ZWRTY3JvbGxQb3NpdGlvbnMgYXZhaWxhYmxlXG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChnZXRTY3JvbGxSZXN0b3JhdGlvbktleSkge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCBtYXRjaGVzLm1hcChtID0+IGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpKSk7XG4gICAgICByZXR1cm4ga2V5IHx8IGxvY2F0aW9uLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2F0aW9uLmtleTtcbiAgfVxuICBmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMgJiYgZ2V0U2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKG5ld1JvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgfVxuICByb3V0ZXIgPSB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2gsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICAvLyBQYXNzdGhyb3VnaCB0byBoaXN0b3J5LWF3YXJlIGNyZWF0ZUhyZWYgdXNlZCBieSB1c2VIcmVmIHNvIHdlIGdldCBwcm9wZXJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXG4gICAgY3JlYXRlSHJlZjogdG8gPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiB0byA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcixcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzXG4gIH07XG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlU3RhdGljSGFuZGxlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IFVOU0FGRV9ERUZFUlJFRF9TWU1CT0wgPSBTeW1ib2woXCJkZWZlcnJlZFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIocm91dGVzLCBvcHRzKSB7XG4gIGludmFyaWFudChyb3V0ZXMubGVuZ3RoID4gMCwgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCIpO1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGJhc2VuYW1lID0gKG9wdHMgPyBvcHRzLmJhc2VuYW1lIDogbnVsbCkgfHwgXCIvXCI7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXMpIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBvcHRzLm1hcFJvdXRlUHJvcGVydGllcztcbiAgfSBlbHNlIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gSWYgdGhleSBhcmUgc3RpbGwgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgdmVyc2lvbiwgd3JhcCBpdCB3aXRoIHRoZSBuZXcgQVBJXG4gICAgbGV0IGRldGVjdEVycm9yQm91bmRhcnkgPSBvcHRzLmRldGVjdEVycm9yQm91bmRhcnk7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gcm91dGUgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgfVxuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMsIHVuZGVmaW5lZCwgbWFuaWZlc3QpO1xuICAvKipcbiAgICogVGhlIHF1ZXJ5KCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkb2N1bWVudCByZXF1ZXN0cywgaW4gd2hpY2ggd2Ugd2FudCB0b1xuICAgKiBjYWxsIGFuIG9wdGlvbmFsIGFjdGlvbiBhbmQgcG90ZW50aWFsbHkgbXVsdGlwbGUgbG9hZGVycyBmb3IgYWxsIG5lc3RlZFxuICAgKiByb3V0ZXMuICBJdCByZXR1cm5zIGEgU3RhdGljSGFuZGxlckNvbnRleHQgb2JqZWN0LCB3aGljaCBpcyB2ZXJ5IHNpbWlsYXJcbiAgICogdG8gdGhlIHJvdXRlciBzdGF0ZSAobG9jYXRpb24sIGxvYWRlckRhdGEsIGFjdGlvbkRhdGEsIGVycm9ycywgZXRjLikgYW5kXG4gICAqIGFsc28gYWRkcyBTU1Itc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgc3RhdHVzQ29kZSBhbmQgaGVhZGVyc1xuICAgKiBmcm9tIGFjdGlvbi9sb2FkZXJzIFJlc3BvbnNlcy5cbiAgICpcbiAgICogSXQgX3Nob3VsZF8gbmV2ZXIgdGhyb3cgYW5kIHNob3VsZCByZXBvcnQgYWxsIGVycm9ycyB0aHJvdWdoIHRoZVxuICAgKiByZXR1cm5lZCBjb250ZXh0LmVycm9ycyBvYmplY3QsIHByb3Blcmx5IGFzc29jaWF0aW5nIGVycm9ycyB0byB0aGVpciBlcnJvclxuICAgKiBib3VuZGFyeS4gIEFkZGl0aW9uYWxseSwgaXQgdHJhY2tzIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHdoaWNoIGNhbiBiZVxuICAgKiB1c2VkIHRvIGVtdWxhdGUgUmVhY3QgZXJyb3IgYm91bmRhcmllcyBkdXJpbmcgU1NyIGJ5IHBlcmZvcm1pbmcgYSBzZWNvbmRcbiAgICogcGFzcyBvbmx5IGRvd24gdG8gdGhlIGJvdW5kYXJ5SWQuXG4gICAqXG4gICAqIFRoZSBvbmUgZXhjZXB0aW9uIHdoZXJlIHdlIGRvIG5vdCByZXR1cm4gYSBTdGF0aWNIYW5kbGVyQ29udGV4dCBpcyB3aGVuIGFcbiAgICogcmVkaXJlY3QgcmVzcG9uc2UgaXMgcmV0dXJuZWQgb3IgdGhyb3duIGZyb20gYW55IGFjdGlvbi9sb2FkZXIuICBXZVxuICAgKiBwcm9wYWdhdGUgdGhhdCBvdXQgYW5kIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIHNvIHRoZSBIVFRQIHNlcnZlciBjYW5cbiAgICogcmV0dXJuIGl0IGRpcmVjdGx5LlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnkocmVxdWVzdCwgX3RlbXAyKSB7XG4gICAgbGV0IHtcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2RcbiAgICAgIH0pO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIHJvdXRlXG4gICAgICB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgICBsZXQge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIHJvdXRlXG4gICAgICB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdoZW4gcmV0dXJuaW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0LCB3ZSBwYXRjaCBiYWNrIGluIHRoZSBsb2NhdGlvbiBoZXJlXG4gICAgLy8gc2luY2Ugd2UgbmVlZCBpdCBmb3IgUmVhY3QgQ29udGV4dC4gIEJ1dCB0aGlzIGhlbHBzIGtlZXAgb3VyIHN1Ym1pdCBhbmRcbiAgICAvLyBsb2FkUm91dGVEYXRhIG9wZXJhdGluZyBvbiBhIFJlcXVlc3QgaW5zdGVhZCBvZiBhIExvY2F0aW9uXG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgYmFzZW5hbWVcbiAgICB9LCByZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcXVlcnlSb3V0ZSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdGFyZ2V0ZWQgcm91dGUgcmVxdWVzdHMsIGVpdGhlclxuICAgKiBmb3IgZmV0Y2ggP19kYXRhIHJlcXVlc3RzIG9yIHJlc291cmNlIHJvdXRlIHJlcXVlc3RzLiAgSW4gdGhpcyBjYXNlLCB3ZVxuICAgKiBhcmUgb25seSBldmVyIGNhbGxpbmcgYSBzaW5nbGUgYWN0aW9uIG9yIGxvYWRlciwgYW5kIHdlIGFyZSByZXR1cm5pbmcgdGhlXG4gICAqIHJldHVybmVkIHZhbHVlIGRpcmVjdGx5LiAgSW4gbW9zdCBjYXNlcywgdGhpcyB3aWxsIGJlIGEgUmVzcG9uc2UgcmV0dXJuZWRcbiAgICogZnJvbSB0aGUgYWN0aW9uL2xvYWRlciwgYnV0IGl0IG1heSBiZSBhIHByaW1pdGl2ZSBvciBvdGhlciB2YWx1ZSBhcyB3ZWxsIC1cbiAgICogYW5kIGluIHN1Y2ggY2FzZXMgdGhlIGNhbGxpbmcgY29udGV4dCBzaG91bGQgaGFuZGxlIHRoYXQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIFdlIGRvIHJlc3BlY3QgdGhlIHRocm93L3JldHVybiBkaWZmZXJlbnRpYXRpb24sIHNvIGlmIGFuIGFjdGlvbi9sb2FkZXJcbiAgICogdGhyb3dzLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgdGhlIHZhbHVlLiAgVGhpcyBpcyBpbXBvcnRhbnQgc28gd2VcbiAgICogY2FuIGRvIHByb3BlciBib3VuZGFyeSBpZGVudGlmaWNhdGlvbiBpbiBSZW1peCB3aGVyZSBhIHRocm93biBSZXNwb25zZVxuICAgKiBtdXN0IGdvIHRvIHRoZSBDYXRjaCBCb3VuZGFyeSBidXQgYSByZXR1cm5lZCBSZXNwb25zZSBpcyBoYXBweS1wYXRoLlxuICAgKlxuICAgKiBPbmUgdGhpbmcgdG8gbm90ZSBpcyB0aGF0IGFueSBSb3V0ZXItaW5pdGlhdGVkIEVycm9ycyB0aGF0IG1ha2Ugc2Vuc2VcbiAgICogdG8gYXNzb2NpYXRlIHdpdGggYSBzdGF0dXMgY29kZSB3aWxsIGJlIHRocm93biBhcyBhbiBFcnJvclJlc3BvbnNlXG4gICAqIGluc3RhbmNlIHdoaWNoIGluY2x1ZGUgdGhlIHJhdyBFcnJvciwgc3VjaCB0aGF0IHRoZSBjYWxsaW5nIGNvbnRleHQgY2FuXG4gICAqIHNlcmlhbGl6ZSB0aGUgZXJyb3IgYXMgdGhleSBzZWUgZml0IHdoaWxlIGluY2x1ZGluZyB0aGUgcHJvcGVyIHJlc3BvbnNlXG4gICAqIGNvZGUuICBFeGFtcGxlcyBoZXJlIGFyZSA0MDQgYW5kIDQwNSBlcnJvcnMgdGhhdCBvY2N1ciBwcmlvciB0byByZWFjaGluZ1xuICAgKiBhbnkgdXNlci1kZWZpbmVkIGxvYWRlcnMuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeVJvdXRlKHJlcXVlc3QsIF90ZW1wMykge1xuICAgIGxldCB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcmVxdWVzdENvbnRleHRcbiAgICB9ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMztcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkID8gbWF0Y2hlcy5maW5kKG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgOiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoaXQgSSBkb24ndCB0aGluaz9cbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBtYXRjaCk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHdlIGdvdCBiYWNrIHJlc3VsdC5lcnJvcnMsIHRoYXQgbWVhbnMgdGhlIGxvYWRlci9hY3Rpb24gdGhyZXdcbiAgICAgIC8vIF9zb21ldGhpbmdfIHRoYXQgd2Fzbid0IGEgUmVzcG9uc2UsIGJ1dCBpdCdzIG5vdCBndWFyYW50ZWVkL3JlcXVpcmVkXG4gICAgICAvLyB0byBiZSBhbiBgaW5zdGFuY2VvZiBFcnJvcmAgZWl0aGVyLCBzbyB3ZSBoYXZlIHRvIHVzZSB0aHJvdyBoZXJlIHRvXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGUgXCJlcnJvclwiIHN0YXRlIG91dHNpZGUgb2YgcXVlcnlJbXBsLlxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIFBpY2sgb2ZmIHRoZSByaWdodCBzdGF0ZSB2YWx1ZSB0byByZXR1cm5cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XG4gICAgICB2YXIgX3Jlc3VsdCRhY3RpdmVEZWZlcnJlO1xuICAgICAgbGV0IGRhdGEgPSBPYmplY3QudmFsdWVzKHJlc3VsdC5sb2FkZXJEYXRhKVswXTtcbiAgICAgIGlmICgoX3Jlc3VsdCRhY3RpdmVEZWZlcnJlID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkcykgIT0gbnVsbCAmJiBfcmVzdWx0JGFjdGl2ZURlZmVycmVbbWF0Y2gucm91dGUuaWRdKSB7XG4gICAgICAgIGRhdGFbVU5TQUZFX0RFRkVSUkVEX1NZTUJPTF0gPSByZXN1bHQuYWN0aXZlRGVmZXJyZWRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHJvdXRlTWF0Y2gpIHtcbiAgICBpbnZhcmlhbnQocmVxdWVzdC5zaWduYWwsIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIik7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoICE9IG51bGwpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHJvdXRlTWF0Y2gpO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IF9leHRlbmRzKHt9LCByZXN1bHQsIHtcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHRocmV3L3JldHVybmVkIGEgUmVzcG9uc2UgaW4gY2FsbExvYWRlck9yQWN0aW9uLCB3ZSB0aHJvd1xuICAgICAgLy8gaXQgdG8gYmFpbCBvdXQgYW5kIHRoZW4gcmV0dXJuIG9yIHRocm93IGhlcmUgYmFzZWQgb24gd2hldGhlciB0aGUgdXNlclxuICAgICAgLy8gcmV0dXJuZWQgb3IgdGhyZXdcbiAgICAgIGlmIChpc1F1ZXJ5Um91dGVSZXNwb25zZShlKSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIC8vIFJlZGlyZWN0cyBhcmUgYWx3YXlzIHJldHVybmVkIHNpbmNlIHRoZXkgZG9uJ3QgcHJvcGFnYXRlIHRvIGNhdGNoXG4gICAgICAvLyBib3VuZGFyaWVzXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIGFjdGlvbk1hdGNoLCByZXF1ZXN0Q29udGV4dCwgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3JcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcImFjdGlvblwiLCByZXF1ZXN0LCBhY3Rpb25NYXRjaCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIHtcbiAgICAgICAgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLFxuICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyBcIigpIGNhbGwgYWJvcnRlZDogXCIgKyByZXF1ZXN0Lm1ldGhvZCArIFwiIFwiICsgcmVxdWVzdC51cmwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb25cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuZGVmaW5lZCwge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgfSk7XG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczogX2V4dGVuZHMoe30sIHJlc3VsdC5oZWFkZXJzID8ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzXG4gICAgICAgIH0gOiB7fSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcmVzdWx0LnN0YXR1c0NvZGUgPyB7XG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZVxuICAgIH0gOiB7fSwge1xuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IF9leHRlbmRzKHt9LCByZXN1bHQuaGVhZGVycyA/IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH0gOiB7fSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoLCBwZW5kaW5nQWN0aW9uRXJyb3IpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICEocm91dGVNYXRjaCAhPSBudWxsICYmIHJvdXRlTWF0Y2gucm91dGUubG9hZGVyKSAmJiAhKHJvdXRlTWF0Y2ggIT0gbnVsbCAmJiByb3V0ZU1hdGNoLnJvdXRlLmxhenkpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1hdGNoZXMgPSByb3V0ZU1hdGNoID8gW3JvdXRlTWF0Y2hdIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXSk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIobSA9PiBtLnJvdXRlLmxvYWRlciB8fCBtLnJvdXRlLmxhenkpO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW20ucm91dGUuaWRdOiBudWxsXG4gICAgICAgIH0pLCB7fSksXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvbkVycm9yIHx8IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChbLi4ubWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIHJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwge1xuICAgICAgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLFxuICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICByZXF1ZXN0Q29udGV4dFxuICAgIH0pKV0pO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyBcIigpIGNhbGwgYWJvcnRlZDogXCIgKyByZXF1ZXN0Lm1ldGhvZCArIFwiIFwiICsgcmVxdWVzdC51cmwpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGNvbnRleHQgPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdBY3Rpb25FcnJvciwgYWN0aXZlRGVmZXJyZWRzKTtcbiAgICAvLyBBZGQgYSBudWxsIGZvciBhbnkgbm9uLWxvYWRlciBtYXRjaGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcbiAgICBsZXQgZXhlY3V0ZWRMb2FkZXJzID0gbmV3IFNldChtYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBtYXRjaC5yb3V0ZS5pZCkpO1xuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAoIWV4ZWN1dGVkTG9hZGVycy5oYXMobWF0Y2gucm91dGUuaWQpKSB7XG4gICAgICAgIGNvbnRleHQubG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLnNpemUgPiAwID8gT2JqZWN0LmZyb21FbnRyaWVzKGFjdGl2ZURlZmVycmVkcy5lbnRyaWVzKCkpIDogbnVsbFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlXG4gIH07XG59XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGVscGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogR2l2ZW4gYW4gZXhpc3RpbmcgU3RhdGljSGFuZGxlckNvbnRleHQgYW5kIGFuIGVycm9yIHRocm93biBhdCByZW5kZXIgdGltZSxcbiAqIHByb3ZpZGUgYW4gdXBkYXRlZCBTdGF0aWNIYW5kbGVyQ29udGV4dCBzdWl0YWJsZSBmb3IgYSBzZWNvbmQgU1NSIHJlbmRlclxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKHJvdXRlcywgY29udGV4dCwgZXJyb3IpIHtcbiAgbGV0IG5ld0NvbnRleHQgPSBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBlcnJvcnM6IHtcbiAgICAgIFtjb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZF06IGVycm9yXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiAoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsIHx8IFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG8obG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCBwcmVwZW5kQmFzZW5hbWUsIHRvLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkICE9IG51bGwgJiYgcmVsYXRpdmUgIT09IFwicGF0aFwiKSB7XG4gICAgLy8gR3JhYiBtYXRjaGVzIHVwIHRvIHRoZSBjYWxsaW5nIHJvdXRlIHNvIG91ciByb3V0ZS1yZWxhdGl2ZSBsb2dpYyBpc1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZS4gIFdoZW4gdXNpbmcgcmVsYXRpdmU6cGF0aCxcbiAgICAvLyBmcm9tUm91dGVJZCBpcyBpZ25vcmVkIHNpbmNlIHRoYXQgaXMgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50XG4gICAgLy8gbG9jYXRpb24gcGF0aFxuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIFJlc29sdmUgdGhlIHJlbGF0aXZlIHBhdGhcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8gPyB0byA6IFwiLlwiLCBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhjb250ZXh0dWFsTWF0Y2hlcykubWFwKG0gPT4gbS5wYXRobmFtZUJhc2UpLCBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIik7XG4gIC8vIFdoZW4gYHRvYCBpcyBub3Qgc3BlY2lmaWVkIHdlIGluaGVyaXQgc2VhcmNoL2hhc2ggZnJvbSB0aGUgY3VycmVudFxuICAvLyBsb2NhdGlvbiwgdW5saWtlIHdoZW4gdG89XCIuXCIgYW5kIHdlIGp1c3QgaW5oZXJpdCB0aGUgcGF0aC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xuICBpZiAodG8gPT0gbnVsbCkge1xuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIH1cbiAgLy8gQWRkIGFuID9pbmRleCBwYXJhbSBmb3IgbWF0Y2hlZCBpbmRleCByb3V0ZXMgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAoKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJiBhY3RpdmVSb3V0ZU1hdGNoICYmIGFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiYgIWhhc05ha2VkSW5kZXhRdWVyeShwYXRoLnNlYXJjaCkpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZS4gIElmXG4gIC8vIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3NcbiAgLy8gdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2hcbiAgLy8gb24gcm9vdCBhY3Rpb25zXG4gIGlmIChwcmVwZW5kQmFzZW5hbWUgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG4vLyBOb3JtYWxpemUgbmF2aWdhdGlvbiBvcHRpb25zIGJ5IGNvbnZlcnRpbmcgZm9ybU1ldGhvZD1HRVQgZm9ybURhdGEgb2JqZWN0cyB0b1xuLy8gVVJMU2VhcmNoUGFyYW1zIHNvIHRoZXkgYmVoYXZlIGlkZW50aWNhbGx5IHRvIGxpbmtzIHdpdGggcXVlcnkgcGFyYW1zXG5mdW5jdGlvbiBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMobm9ybWFsaXplRm9ybU1ldGhvZCwgaXNGZXRjaGVyLCBwYXRoLCBvcHRzKSB7XG4gIC8vIFJldHVybiBsb2NhdGlvbiB2ZXJiYXRpbSBvbiBub24tc3VibWlzc2lvbiBuYXZpZ2F0aW9uc1xuICBpZiAoIW9wdHMgfHwgIWlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aFxuICAgIH07XG4gIH1cbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiBvcHRzLmZvcm1NZXRob2RcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBsZXQgZ2V0SW52YWxpZEJvZHlFcnJvciA9ICgpID0+ICh7XG4gICAgcGF0aCxcbiAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgIHR5cGU6IFwiaW52YWxpZC1ib2R5XCJcbiAgICB9KVxuICB9KTtcbiAgLy8gQ3JlYXRlIGEgU3VibWlzc2lvbiBvbiBub24tR0VUIG5hdmlnYXRpb25zXG4gIGxldCByYXdGb3JtTWV0aG9kID0gb3B0cy5mb3JtTWV0aG9kIHx8IFwiZ2V0XCI7XG4gIGxldCBmb3JtTWV0aG9kID0gbm9ybWFsaXplRm9ybU1ldGhvZCA/IHJhd0Zvcm1NZXRob2QudG9VcHBlckNhc2UoKSA6IHJhd0Zvcm1NZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKTtcbiAgaWYgKG9wdHMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICAvLyB0ZXh0IG9ubHkgc3VwcG9ydCBQT1NUL1BVVC9QQVRDSC9ERUxFVEUgc3VibWlzc2lvbnNcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgbGV0IHRleHQgPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gb3B0cy5ib2R5IDogb3B0cy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEgfHwgb3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID9cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI3BsYWluLXRleHQtZm9ybS1kYXRhXG4gICAgICBBcnJheS5mcm9tKG9wdHMuYm9keS5lbnRyaWVzKCkpLnJlZHVjZSgoYWNjLCBfcmVmMykgPT4ge1xuICAgICAgICBsZXQgW25hbWUsIHZhbHVlXSA9IF9yZWYzO1xuICAgICAgICByZXR1cm4gXCJcIiArIGFjYyArIG5hbWUgKyBcIj1cIiArIHZhbHVlICsgXCJcXG5cIjtcbiAgICAgIH0sIFwiXCIpIDogU3RyaW5nKG9wdHMuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICAvLyBqc29uIG9ubHkgc3VwcG9ydHMgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uob3B0cy5ib2R5KSA6IG9wdHMuYm9keTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KHR5cGVvZiBGb3JtRGF0YSA9PT0gXCJmdW5jdGlvblwiLCBcIkZvcm1EYXRhIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiKTtcbiAgbGV0IHNlYXJjaFBhcmFtcztcbiAgbGV0IGZvcm1EYXRhO1xuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuZm9ybURhdGEpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gb3B0cy5ib2R5O1xuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICBmb3JtRGF0YSxcbiAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgdGV4dDogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9O1xuICB9XG4gIC8vIEZsYXR0ZW4gc3VibWlzc2lvbiBvbnRvIFVSTFNlYXJjaFBhcmFtcyBmb3IgR0VUIHN1Ym1pc3Npb25zXG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICAvLyBPbiBHRVQgbmF2aWdhdGlvbiBzdWJtaXNzaW9ucyB3ZSBjYW4gZHJvcCB0aGUgP2luZGV4IHBhcmFtIGZyb20gdGhlXG4gIC8vIHJlc3VsdGluZyBsb2NhdGlvbiBzaW5jZSBhbGwgbG9hZGVycyB3aWxsIHJ1bi4gIEJ1dCBmZXRjaGVyIEdFVCBzdWJtaXNzaW9uc1xuICAvLyBvbmx5IHJ1biBhIHNpbmdsZSBsb2FkZXIgc28gd2UgbmVlZCB0byBwcmVzZXJ2ZSBhbnkgaW5jb21pbmcgP2luZGV4IHBhcmFtc1xuICBpZiAoaXNGZXRjaGVyICYmIHBhcnNlZFBhdGguc2VhcmNoICYmIGhhc05ha2VkSW5kZXhRdWVyeShwYXJzZWRQYXRoLnNlYXJjaCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgXCJcIik7XG4gIH1cbiAgcGFyc2VkUGF0aC5zZWFyY2ggPSBcIj9cIiArIHNlYXJjaFBhcmFtcztcbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLFxuICAgIHN1Ym1pc3Npb25cbiAgfTtcbn1cbi8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyBhbnkgY2F1Z2h0IGVycm9yIGFzIHRoZXkgYXJlbid0IGdvaW5nIHRvXG4vLyByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpIHtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXM7XG4gIGlmIChib3VuZGFyeUlkKSB7XG4gICAgbGV0IGluZGV4ID0gbWF0Y2hlcy5maW5kSW5kZXgobSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZGFyeU1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKGhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsb2NhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsIGNhbmNlbGxlZEZldGNoZXJMb2FkcywgZmV0Y2hMb2FkTWF0Y2hlcywgZmV0Y2hSZWRpcmVjdElkcywgcm91dGVzVG9Vc2UsIGJhc2VuYW1lLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKSB7XG4gIGxldCBhY3Rpb25SZXN1bHQgPSBwZW5kaW5nRXJyb3IgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF0gOiBwZW5kaW5nQWN0aW9uRGF0YSA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0FjdGlvbkRhdGEpWzBdIDogdW5kZWZpbmVkO1xuICBsZXQgY3VycmVudFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0YXRlLmxvY2F0aW9uKTtcbiAgbGV0IG5leHRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChsb2NhdGlvbik7XG4gIC8vIFBpY2sgbmF2aWdhdGlvbiBtYXRjaGVzIHRoYXQgYXJlIG5ldC1uZXcgb3IgcXVhbGlmeSBmb3IgcmV2YWxpZGF0aW9uXG4gIGxldCBib3VuZGFyeUlkID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpO1xuICBsZXQgbmF2aWdhdGlvbk1hdGNoZXMgPSBib3VuZGFyeU1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAobWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgLy8gV2UgaGF2ZW4ndCBsb2FkZWQgdGhpcyByb3V0ZSB5ZXQgc28gd2UgZG9uJ3Qga25vdyBpZiBpdCdzIGdvdCBhIGxvYWRlciFcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2gucm91dGUubG9hZGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGwgdGhlIGxvYWRlciBvbiBuZXcgcm91dGUgaW5zdGFuY2VzIGFuZCBwZW5kaW5nIGRlZmVyIGNhbmNlbGxhdGlvbnNcbiAgICBpZiAoaXNOZXdMb2FkZXIoc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKSB8fCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5zb21lKGlkID0+IGlkID09PSBtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciB3aGVuIHdlIHJldmFsaWRhdGUuICBJZiB0aGUgcm91dGVcbiAgICAvLyBwcm92aWRlcyBpdCdzIG93biBpbXBsZW1lbnRhdGlvbiwgdGhlbiB3ZSBnaXZlIHRoZW0gZnVsbCBjb250cm9sIGJ1dFxuICAgIC8vIHByb3ZpZGUgdGhpcyB2YWx1ZSBzbyB0aGV5IGNhbiBsZXZlcmFnZSBpdCBpZiBuZWVkZWQgYWZ0ZXIgdGhleSBjaGVja1xuICAgIC8vIHRoZWlyIG93biBzcGVjaWZpYyB1c2UgY2FzZXNcbiAgICBsZXQgY3VycmVudFJvdXRlTWF0Y2ggPSBzdGF0ZS5tYXRjaGVzW2luZGV4XTtcbiAgICBsZXQgbmV4dFJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwgX2V4dGVuZHMoe1xuICAgICAgY3VycmVudFVybCxcbiAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXNcbiAgICB9LCBzdWJtaXNzaW9uLCB7XG4gICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTpcbiAgICAgIC8vIEZvcmNlZCByZXZhbGlkYXRpb24gZHVlIHRvIHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGVcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHxcbiAgICAgIC8vIENsaWNrZWQgdGhlIHNhbWUgbGluaywgcmVzdWJtaXR0ZWQgYSBHRVQgZm9ybVxuICAgICAgY3VycmVudFVybC5wYXRobmFtZSArIGN1cnJlbnRVcmwuc2VhcmNoID09PSBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHxcbiAgICAgIC8vIFNlYXJjaCBwYXJhbXMgYWZmZWN0IGFsbCBsb2FkZXJzXG4gICAgICBjdXJyZW50VXJsLnNlYXJjaCAhPT0gbmV4dFVybC5zZWFyY2ggfHwgaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRSb3V0ZU1hdGNoLCBuZXh0Um91dGVNYXRjaClcbiAgICB9KSk7XG4gIH0pO1xuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVycyA9IFtdO1xuICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKGYsIGtleSkgPT4ge1xuICAgIC8vIERvbid0IHJldmFsaWRhdGUgaWYgZmV0Y2hlciB3b24ndCBiZSBwcmVzZW50IGluIHRoZSBzdWJzZXF1ZW50IHJlbmRlclxuICAgIGlmICghbWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG4gICAgLy8gSWYgdGhlIGZldGNoZXIgcGF0aCBubyBsb25nZXIgbWF0Y2hlcywgcHVzaCBpdCBpbiB3aXRoIG51bGwgbWF0Y2hlcyBzb1xuICAgIC8vIHdlIGNhbiB0cmlnZ2VyIGEgNDA0IGluIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YS4gIE5vdGUgdGhpcyBpc1xuICAgIC8vIGN1cnJlbnRseSBvbmx5IGEgdXNlLWNhc2UgZm9yIFJlbWl4IEhNUiB3aGVyZSB0aGUgcm91dGUgdHJlZSBjYW4gY2hhbmdlXG4gICAgLy8gYXQgcnVudGltZSBhbmQgcmVtb3ZlIGEgcm91dGUgcHJldmlvdXNseSBsb2FkZWQgdmlhIGEgZmV0Y2hlclxuICAgIGlmICghZmV0Y2hlck1hdGNoZXMpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBudWxsLFxuICAgICAgICBtYXRjaDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJldmFsaWRhdGluZyBmZXRjaGVycyBhcmUgZGVjb3VwbGVkIGZyb20gdGhlIHJvdXRlIG1hdGNoZXMgc2luY2UgdGhleVxuICAgIC8vIGxvYWQgZnJvbSBhIHN0YXRpYyBocmVmLiAgVGhleSByZXZhbGlkYXRlIGJhc2VkIG9uIGV4cGxpY2l0IHJldmFsaWRhdGlvblxuICAgIC8vIChzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlKVxuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXJNYXRjaCA9IGdldFRhcmdldE1hdGNoKGZldGNoZXJNYXRjaGVzLCBmLnBhdGgpO1xuICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgaWYgKGZldGNoUmVkaXJlY3RJZHMuaGFzKGtleSkpIHtcbiAgICAgIC8vIE5ldmVyIHRyaWdnZXIgYSByZXZhbGlkYXRpb24gb2YgYW4gYWN0aXZlbHkgcmVkaXJlY3RpbmcgZmV0Y2hlclxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIC8vIEFsd2F5cyByZXZhbGlkYXRlIGlmIHRoZSBmZXRjaGVyIHdhcyBjYW5jZWxsZWRcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlICE9PSBcImlkbGVcIiAmJiBmZXRjaGVyLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgdGhlIGZldGNoZXIgaGFzbid0IGV2ZXIgY29tcGxldGVkIGxvYWRpbmcgeWV0LCB0aGVuIHRoaXMgaXNuJ3QgYVxuICAgICAgLy8gcmV2YWxpZGF0aW9uLCBpdCB3b3VsZCBqdXN0IGJlIGEgYnJhbmQgbmV3IGxvYWQgaWYgYW4gZXhwbGljaXRcbiAgICAgIC8vIHJldmFsaWRhdGlvbiBpcyByZXF1aXJlZFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBmYWxsIGJhY2sgb24gYW55IHVzZXItZGVmaW5lZCBzaG91bGRSZXZhbGlkYXRlLCBkZWZhdWx0aW5nXG4gICAgICAvLyB0byBleHBsaWNpdCByZXZhbGlkYXRpb25zIG9ubHlcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGZldGNoZXJNYXRjaCwgX2V4dGVuZHMoe1xuICAgICAgICBjdXJyZW50VXJsLFxuICAgICAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzW3N0YXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgICBuZXh0VXJsLFxuICAgICAgICBuZXh0UGFyYW1zOiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zXG4gICAgICB9LCBzdWJtaXNzaW9uLCB7XG4gICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgbWF0Y2g6IGZldGNoZXJNYXRjaCxcbiAgICAgICAgY29udHJvbGxlcjogbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW25hdmlnYXRpb25NYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVyc107XG59XG5mdW5jdGlvbiBpc05ld0xvYWRlcihjdXJyZW50TG9hZGVyRGF0YSwgY3VycmVudE1hdGNoLCBtYXRjaCkge1xuICBsZXQgaXNOZXcgPVxuICAvLyBbYV0gLT4gW2EsIGJdXG4gICFjdXJyZW50TWF0Y2ggfHxcbiAgLy8gW2EsIGJdIC0+IFthLCBjXVxuICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkO1xuICAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBoYXZlIGRhdGEgZm9yIGEgcmUtdXNlZCByb3V0ZSwgcG90ZW50aWFsbHlcbiAgLy8gZnJvbSBhIHByaW9yIGVycm9yIG9yIGZyb20gYSBjYW5jZWxsZWQgcGVuZGluZyBkZWZlcnJlZFxuICBsZXQgaXNNaXNzaW5nRGF0YSA9IGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkO1xuICAvLyBBbHdheXMgbG9hZCBpZiB0aGlzIGlzIGEgbmV0LW5ldyByb3V0ZSBvciB3ZSBkb24ndCB5ZXQgaGF2ZSBkYXRhXG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8XG4gICAgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgIGN1cnJlbnRQYXRoICE9IG51bGwgJiYgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGxvYWRlck1hdGNoLCBhcmcpIHtcbiAgaWYgKGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgcm91dGVDaG9pY2UgPSBsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKGFyZyk7XG4gICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cbi8qKlxuICogRXhlY3V0ZSByb3V0ZS5sYXp5KCkgbWV0aG9kcyB0byBsYXppbHkgbG9hZCByb3V0ZSBtb2R1bGVzIChsb2FkZXIsIGFjdGlvbixcbiAqIHNob3VsZFJldmFsaWRhdGUpIGFuZCB1cGRhdGUgdGhlIHJvdXRlTWFuaWZlc3QgaW4gcGxhY2Ugd2hpY2ggc2hhcmVzIG9iamVjdHNcbiAqIHdpdGggZGF0YVJvdXRlcyBzbyB0aG9zZSBnZXQgdXBkYXRlZCBhcyB3ZWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkTGF6eVJvdXRlTW9kdWxlKHJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KSB7XG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuICAvLyBJZiB0aGUgbGF6eSByb3V0ZSBmdW5jdGlvbiB3YXMgZXhlY3V0ZWQgYW5kIHJlbW92ZWQgYnkgYW5vdGhlciBwYXJhbGxlbFxuICAvLyBjYWxsIHRoZW4gd2UgY2FuIHJldHVybiAtIGZpcnN0IGxhenkoKSB0byBmaW5pc2ggd2lucyBiZWNhdXNlIHRoZSByZXR1cm5cbiAgLy8gdmFsdWUgb2YgbGF6eSBpcyBleHBlY3RlZCB0byBiZSBzdGF0aWNcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCByb3V0ZVRvVXBkYXRlID0gbWFuaWZlc3Rbcm91dGUuaWRdO1xuICBpbnZhcmlhbnQocm91dGVUb1VwZGF0ZSwgXCJObyByb3V0ZSBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgLy8gVXBkYXRlIHRoZSByb3V0ZSBpbiBwbGFjZS4gIFRoaXMgc2hvdWxkIGJlIHNhZmUgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxuICAvLyB3ZSBjb3VsZCB5ZXQgYmUgc2l0dGluZyBvbiB0aGlzIHJvdXRlIGFzIHdlIGNhbid0IGdldCB0aGVyZSB3aXRob3V0XG4gIC8vIHJlc29sdmluZyBsYXp5KCkgZmlyc3QuXG4gIC8vXG4gIC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIEhNUiBcInVwZGF0ZVwiIHVzZS1jYXNlIHdoZXJlIHdlIG1heSBhY3RpdmVseSBiZVxuICAvLyBvbiB0aGUgcm91dGUgYmVpbmcgdXBkYXRlZC4gIFRoZSBtYWluIGNvbmNlcm4gYm9pbHMgZG93biB0byBcImRvZXMgdGhpc1xuICAvLyBtdXRhdGlvbiBhZmZlY3QgYW55IG9uZ29pbmcgbmF2aWdhdGlvbnMgb3IgYW55IGN1cnJlbnQgc3RhdGUubWF0Y2hlc1xuICAvLyB2YWx1ZXM/XCIuICBJZiBub3QsIGl0IHNob3VsZCBiZSBzYWZlIHRvIHVwZGF0ZSBpbiBwbGFjZS5cbiAgbGV0IHJvdXRlVXBkYXRlcyA9IHt9O1xuICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9IHJvdXRlVG9VcGRhdGVbbGF6eVJvdXRlUHJvcGVydHldO1xuICAgIGxldCBpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgPSBzdGF0aWNSb3V0ZVZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgIGxhenlSb3V0ZVByb3BlcnR5ICE9PSBcImhhc0Vycm9yQm91bmRhcnlcIjtcbiAgICB3YXJuaW5nKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQsIFwiUm91dGUgXFxcIlwiICsgcm91dGVUb1VwZGF0ZS5pZCArIFwiXFxcIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgXCIgKyBcImRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFwiICsgKFwiVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgd2lsbCBiZSBpZ25vcmVkLlwiKSk7XG4gICAgaWYgKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiYgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkpKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID0gbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgLy8gTXV0YXRlIHRoZSByb3V0ZSB3aXRoIHRoZSBwcm92aWRlZCB1cGRhdGVzLiAgRG8gdGhpcyBmaXJzdCBzbyB3ZSBwYXNzXG4gIC8vIHRoZSB1cGRhdGVkIHZlcnNpb24gdG8gbWFwUm91dGVQcm9wZXJ0aWVzXG4gIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwgcm91dGVVcGRhdGVzKTtcbiAgLy8gTXV0YXRlIHRoZSBgaGFzRXJyb3JCb3VuZGFyeWAgcHJvcGVydHkgb24gdGhlIHJvdXRlIGJhc2VkIG9uIHRoZSByb3V0ZVxuICAvLyB1cGRhdGVzIGFuZCByZW1vdmUgdGhlIGBsYXp5YCBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNvbHZlIHRoZSBsYXp5XG4gIC8vIHJvdXRlIGFnYWluLlxuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIF9leHRlbmRzKHt9LCBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGVUb1VwZGF0ZSksIHtcbiAgICBsYXp5OiB1bmRlZmluZWRcbiAgfSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlck9yQWN0aW9uKHR5cGUsIHJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGxldCByZXN1bHRUeXBlO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q7XG4gIGxldCBydW5IYW5kbGVyID0gaGFuZGxlciA9PiB7XG4gICAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgICBsZXQgcmVqZWN0O1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gcmVqZWN0ID0gcik7XG4gICAgb25SZWplY3QgPSAoKSA9PiByZWplY3QoKTtcbiAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2hhbmRsZXIoe1xuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgY29udGV4dDogb3B0cy5yZXF1ZXN0Q29udGV4dFxuICAgIH0pLCBhYm9ydFByb21pc2VdKTtcbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBSdW4gc3RhdGljYWxseSBkZWZpbmVkIGhhbmRsZXIgaW4gcGFyYWxsZWwgd2l0aCBsYXp5KClcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBsZXQgdGhlIGxhenkoKSBleGVjdXRpb24gZmluaXNoIHNvIHdlIGtub3cgaWYgdGhpc1xuICAgICAgICAvLyByb3V0ZSBoYXMgYSBib3VuZGFyeSB0aGF0IGNhbiBoYW5kbGUgdGhlIGVycm9yXG4gICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgaGFuZGxlckVycm9yID0gZTtcbiAgICAgICAgfSksIGxvYWRMYXp5Um91dGVNb2R1bGUobWF0Y2gucm91dGUsIG1hcFJvdXRlUHJvcGVydGllcywgbWFuaWZlc3QpXSk7XG4gICAgICAgIGlmIChoYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBoYW5kbGVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9hZCBsYXp5IHJvdXRlIG1vZHVsZSwgdGhlbiBydW4gYW55IHJldHVybmVkIGhhbmRsZXJcbiAgICAgICAgYXdhaXQgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCk7XG4gICAgICAgIGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAvLyBIYW5kbGVyIHN0aWxsIHJ1biBldmVuIGlmIHdlIGdvdCBpbnRlcnJ1cHRlZCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXG4gICAgICAgICAgLy8gcHJldmlvdXNseS1sYXp5LWxvYWRlZCByb3V0ZXNcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXp5KCkgcm91dGUgaGFzIG5vIGxvYWRlciB0byBydW4uICBTaG9ydCBjaXJjdWl0IGhlcmUgc28gd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoaXQgdGhlIGludmFyaWFudCBiZWxvdyB0aGF0IGVycm9ycyBvbiByZXR1cm5pbmcgdW5kZWZpbmVkLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaW52YXJpYW50KHJlc3VsdCAhPT0gdW5kZWZpbmVkLCBcIllvdSBkZWZpbmVkIFwiICsgKHR5cGUgPT09IFwiYWN0aW9uXCIgPyBcImFuIGFjdGlvblwiIDogXCJhIGxvYWRlclwiKSArIFwiIGZvciByb3V0ZSBcIiArIChcIlxcXCJcIiArIG1hdGNoLnJvdXRlLmlkICsgXCJcXFwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZyb20geW91ciBgXCIgKyB0eXBlICsgXCJgIFwiKSArIFwiZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBgbnVsbGAuXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0VHlwZSA9IFJlc3VsdFR5cGUuZXJyb3I7XG4gICAgcmVzdWx0ID0gZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob25SZWplY3QpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgfVxuICB9XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgICAvLyBQcm9jZXNzIHJlZGlyZWN0c1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXMpKSB7XG4gICAgICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICAgIGludmFyaWFudChsb2NhdGlvbiwgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiKTtcbiAgICAgIC8vIFN1cHBvcnQgcmVsYXRpdmUgcm91dGluZyBpbiBpbnRlcm5hbCByZWRpcmVjdHNcbiAgICAgIGlmICghQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8obmV3IFVSTChyZXF1ZXN0LnVybCksIG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5pbmRleE9mKG1hdGNoKSArIDEpLCBiYXNlbmFtZSwgdHJ1ZSwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIGlmICghb3B0cy5pc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBsb2NhdGlvbikgOiBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGU6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSAhPT0gbnVsbCxcbiAgICAgICAgcmVsb2FkRG9jdW1lbnQ6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpICE9PSBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCB1bndyYXBwaW5nLiAgV2UgZG8gdGhpcyB3aXRoIHRoZSBRdWVyeVJvdXRlUmVzcG9uc2Ugd3JhcHBlclxuICAgIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4ga25vdyB3aGV0aGVyIGl0IHdhcyByZXR1cm5lZCBvciB0aHJvd25cbiAgICBpZiAob3B0cy5pc1JvdXRlUmVxdWVzdCkge1xuICAgICAgbGV0IHF1ZXJ5Um91dGVSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciA/IFJlc3VsdFR5cGUuZXJyb3IgOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHRcbiAgICAgIH07XG4gICAgICB0aHJvdyBxdWVyeVJvdXRlUmVzcG9uc2U7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAvLyBDaGVjayBiZXR3ZWVuIHdvcmQgYm91bmRhcmllcyBpbnN0ZWFkIG9mIHN0YXJ0c1dpdGgoKSBkdWUgdG8gdGhlIGxhc3RcbiAgICAvLyBwYXJhZ3JhcGggb2YgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LXR5cGVcbiAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHJlc3VsdFR5cGUsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YSksXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgZGF0YSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgIH07XG4gIH1cbiAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgIGVycm9yOiByZXN1bHRcbiAgICB9O1xuICB9XG4gIGlmIChpc0RlZmVycmVkRGF0YShyZXN1bHQpKSB7XG4gICAgdmFyIF9yZXN1bHQkaW5pdCwgX3Jlc3VsdCRpbml0MjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZCxcbiAgICAgIGRlZmVycmVkRGF0YTogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogKF9yZXN1bHQkaW5pdCA9IHJlc3VsdC5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdCRpbml0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6ICgoX3Jlc3VsdCRpbml0MiA9IHJlc3VsdC5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdCRpbml0Mi5oZWFkZXJzKSAmJiBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgZGF0YTogcmVzdWx0XG4gIH07XG59XG4vLyBVdGlsaXR5IG1ldGhvZCBmb3IgY3JlYXRpbmcgdGhlIFJlcXVlc3QgaW5zdGFuY2VzIGZvciBsb2FkZXJzL2FjdGlvbnMgZHVyaW5nXG4vLyBjbGllbnQtc2lkZSBuYXZpZ2F0aW9ucyBhbmQgZmV0Y2hlcy4gIER1cmluZyBTU1Igd2Ugd2lsbCBhbHdheXMgaGF2ZSBhXG4vLyBSZXF1ZXN0IGluc3RhbmNlIGZyb20gdGhlIHN0YXRpYyBoYW5kbGVyIChxdWVyeS9xdWVyeVJvdXRlKVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdCA9IHtcbiAgICBzaWduYWxcbiAgfTtcbiAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtRW5jVHlwZVxuICAgIH0gPSBzdWJtaXNzaW9uO1xuICAgIC8vIERpZG4ndCB0aGluayB3ZSBuZWVkZWQgdGhpcyBidXQgaXQgdHVybnMgb3V0IHVubGlrZSBvdGhlciBtZXRob2RzLCBwYXRjaFxuICAgIC8vIHdvbid0IGJlIHByb3Blcmx5IG5vcm1hbGl6ZWQgdG8gdXBwZXJjYXNlIGFuZCByZXN1bHRzIGluIGEgNDA1IGVycm9yLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kXG4gICAgaW5pdC5tZXRob2QgPSBmb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaW5pdC5oZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBmb3JtRW5jVHlwZVxuICAgICAgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24udGV4dDtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICYmIHN1Ym1pc3Npb24uZm9ybURhdGEpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoc3VibWlzc2lvbi5mb3JtRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSkge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY29udmVydGluZy1hbi1lbnRyeS1saXN0LXRvLWEtbGlzdC1vZi1uYW1lLXZhbHVlLXBhaXJzXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcykge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nRXJyb3IsIGFjdGl2ZURlZmVycmVkcykge1xuICAvLyBGaWxsIGluIGxvYWRlckRhdGEvZXJyb3JzIGZyb20gb3VyIGxvYWRlcnNcbiAgbGV0IGxvYWRlckRhdGEgPSB7fTtcbiAgbGV0IGVycm9ycyA9IG51bGw7XG4gIGxldCBzdGF0dXNDb2RlO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVycyA9IHt9O1xuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KCFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCIpO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxuICAgICAgLy8gdGhhdCB0aHJvd3MgYSBsb2FkZXIgZXJyb3IsIGFuZCB0aGVuIGNsZWFyIGl0IG91dCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAvLyBpdCB3YXMgY29uc3VtZWRcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF07XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcbiAgICAgIC8vIFByZWZlciBoaWdoZXIgZXJyb3IgdmFsdWVzIGlmIGxvd2VyIGVycm9ycyBidWJibGUgdG8gdGhlIHNhbWUgYm91bmRhcnlcbiAgICAgIGlmIChlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPT0gbnVsbCkge1xuICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIG91ciBhbnkgcHJpb3IgbG9hZGVyRGF0YSBmb3IgdGhlIHRocm93aW5nIHJvdXRlXG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIE9uY2Ugd2UgZmluZCBvdXIgZmlyc3QgKGhpZ2hlc3QpIGVycm9yLCB3ZSBzZXQgdGhlIHN0YXR1cyBjb2RlIGFuZFxuICAgICAgLy8gcHJldmVudCBkZWVwZXIgc3RhdHVzIGNvZGVzIGZyb20gb3ZlcnJpZGluZ1xuICAgICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgICAgICBzdGF0dXNDb2RlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2V0KGlkLCByZXN1bHQuZGVmZXJyZWREYXRhKTtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfVxuICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxuICAgICAgLy8gbG9hZGVycyBhcmUgc3VjY2Vzc2Z1bCB3ZSB0YWtlIHRoZSBkZWVwZXN0IHN0YXR1cyBjb2RlLlxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgJiYgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJiAhZm91bmRFcnJvcikge1xuICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvLyBJZiB3ZSBkaWRuJ3QgY29uc3VtZSB0aGUgcGVuZGluZyBhY3Rpb24gZXJyb3IgKGkuZS4sIGFsbCBsb2FkZXJzXG4gIC8vIHJlc29sdmVkKSwgdGhlbiBjb25zdW1lIGl0IGhlcmUuICBBbHNvIGNsZWFyIG91dCBhbnkgbG9hZGVyRGF0YSBmb3IgdGhlXG4gIC8vIHRocm93aW5nIHJvdXRlXG4gIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICBlcnJvcnMgPSBwZW5kaW5nRXJyb3I7XG4gICAgbG9hZGVyRGF0YVtPYmplY3Qua2V5cyhwZW5kaW5nRXJyb3IpWzBdXSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nRXJyb3IsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKSB7XG4gIGxldCB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnNcbiAgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmVzdWx0cywgcGVuZGluZ0Vycm9yLCBhY3RpdmVEZWZlcnJlZHMpO1xuICAvLyBQcm9jZXNzIHJlc3VsdHMgZnJvbSBvdXIgcmV2YWxpZGF0aW5nIGZldGNoZXJzXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgbWF0Y2gsXG4gICAgICBjb250cm9sbGVyXG4gICAgfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoZmV0Y2hlclJlc3VsdHMgIT09IHVuZGVmaW5lZCAmJiBmZXRjaGVyUmVzdWx0c1tpbmRleF0gIT09IHVuZGVmaW5lZCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuICAgIC8vIFByb2Nlc3MgZmV0Y2hlciBub24tcmVkaXJlY3QgZXJyb3JzXG4gICAgaWYgKGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgYWJvcnRlZCBmZXRjaGVyc1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0gX2V4dGVuZHMoe30sIGVycm9ycywge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgcmVkaXJlY3RzIHNob3VsZCBnZXQgcHJvY2Vzc2VkIGFib3ZlLCBidXQgd2VcbiAgICAgIC8vIGtlZXAgdGhpcyB0byB0eXBlIG5hcnJvdyB0byBhIHN1Y2Nlc3MgcmVzdWx0IGluIHRoZSBlbHNlXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGRlZmVycmVkIGRhdGEgc2hvdWxkIGJlIGF3YWl0ZWQgZm9yIGZldGNoZXJzXG4gICAgICAvLyBpbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEobG9hZGVyRGF0YSwgbmV3TG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSB7XG4gIGxldCBtZXJnZWRMb2FkZXJEYXRhID0gX2V4dGVuZHMoe30sIG5ld0xvYWRlckRhdGEpO1xuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgaWYgKG5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpZiAobmV3TG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IG5ld0xvYWRlckRhdGFbaWRdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCAmJiBtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIC8vIFByZXNlcnZlIGV4aXN0aW5nIGtleXMgbm90IGluY2x1ZGVkIGluIG5ld0xvYWRlckRhdGEgYW5kIHdoZXJlIGEgbG9hZGVyXG4gICAgICAvLyB3YXNuJ3QgcmVtb3ZlZCBieSBITVJcbiAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbG9hZGVyRGF0YVtpZF07XG4gICAgfVxuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgLy8gRG9uJ3Qga2VlcCBhbnkgbG9hZGVyIGRhdGEgYmVsb3cgdGhlIGJvdW5kYXJ5XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXG4vLyByb3V0ZSBzcGVjaWZpZWQgYnkgcm91dGVJZCkgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yIGJvdW5kYXJ5LFxuLy8gZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCByb3V0ZUlkKSB7XG4gIGxldCBlbGlnaWJsZU1hdGNoZXMgPSByb3V0ZUlkID8gbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSkgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQobSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8IG1hdGNoZXNbMF07XG59XG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlcykge1xuICAvLyBQcmVmZXIgYSByb290IGxheW91dCByb3V0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2Ugc2hpbSBpbiBhIHJvdXRlIG9iamVjdFxuICBsZXQgcm91dGUgPSByb3V0ZXMuZmluZChyID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IFwiX19zaGltLWVycm9yLXJvdXRlX19cIlxuICB9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFt7XG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICByb3V0ZVxuICAgIH1dLFxuICAgIHJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywgX3RlbXA0KSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWUsXG4gICAgcm91dGVJZCxcbiAgICBtZXRob2QsXG4gICAgdHlwZVxuICB9ID0gX3RlbXA0ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNDtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZCArIFwiIHJlcXVlc3QgdG8gXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCIgYnV0IFwiICsgKFwiZGlkIG5vdCBwcm92aWRlIGEgYGxvYWRlcmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGVmZXItYWN0aW9uXCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiZGVmZXIoKSBpcyBub3Qgc3VwcG9ydGVkIGluIGFjdGlvbnNcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW52YWxpZC1ib2R5XCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIlJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIk5vIHJvdXRlIG1hdGNoZXMgVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCIgcmVxdWVzdCB0byBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIiBidXQgXCIgKyAoXCJkaWQgbm90IHByb3ZpZGUgYW4gYGFjdGlvbmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFxcXCJcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCJcXFwiXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzIHx8IDUwMCwgc3RhdHVzVGV4dCwgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksIHRydWUpO1xufVxuLy8gRmluZCBhbnkgcmV0dXJuZWQgcmVkaXJlY3QgZXJyb3JzLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpZHg6IGlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aChfZXh0ZW5kcyh7fSwgcGFyc2VkUGF0aCwge1xuICAgIGhhc2g6IFwiXCJcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhLCBiKSB7XG4gIGlmIChhLnBhdGhuYW1lICE9PSBiLnBhdGhuYW1lIHx8IGEuc2VhcmNoICE9PSBiLnNlYXJjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UgLT4gL3BhZ2UjaGFzaFxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI290aGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgdGhlIGhhc2ggaXMgcmVtb3ZlZCB0aGUgYnJvd3NlciB3aWxsIHJlLXBlcmZvcm0gYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3I7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkRGF0YSh2YWx1ZSkge1xuICBsZXQgZGVmZXJyZWQgPSB2YWx1ZTtcbiAgcmV0dXJuIGRlZmVycmVkICYmIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZlcnJlZC5yZXNvbHZlRGF0YSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkge1xuICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIHJldHVybiBzdGF0dXMgPj0gMzAwICYmIHN0YXR1cyA8PSAzOTkgJiYgbG9jYXRpb24gIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iaikge1xuICByZXR1cm4gb2JqICYmIGlzUmVzcG9uc2Uob2JqLnJlc3BvbnNlKSAmJiAob2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZGF0YSB8fCBvYmoudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBzaWduYWxzLCBpc0ZldGNoZXIsIGN1cnJlbnRMb2FkZXJEYXRhKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbWF0Y2gsIHRoZW4gd2UgY2FuIGhhdmUgYSBkZWZlcnJlZCByZXN1bHQgdG8gZG9cbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcbiAgICAvLyByZW1vdmVkIGR1cmluZyBITVJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRNYXRjaCA9IGN1cnJlbnRNYXRjaGVzLmZpbmQobSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID0gY3VycmVudE1hdGNoICE9IG51bGwgJiYgIWlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSAmJiAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkgJiYgKGlzRmV0Y2hlciB8fCBpc1JldmFsaWRhdGluZ0xvYWRlcikpIHtcbiAgICAgIC8vIE5vdGU6IHdlIGRvIG5vdCBoYXZlIHRvIHRvdWNoIGFjdGl2ZURlZmVycmVkcyBoZXJlIHNpbmNlIHdlIHJhY2UgdGhlbVxuICAgICAgLy8gYWdhaW5zdCB0aGUgc2lnbmFsIGluIHJlc29sdmVEZWZlcnJlZERhdGEgYW5kIHRoZXknbGwgZ2V0IGFib3J0ZWRcbiAgICAgIC8vIHRoZXJlIGlmIG5lZWRlZFxuICAgICAgbGV0IHNpZ25hbCA9IHNpZ25hbHNbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KHNpZ25hbCwgXCJFeHBlY3RlZCBhbiBBYm9ydFNpZ25hbCBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXIgZGVmZXJyZWQgcmVzdWx0XCIpO1xuICAgICAgYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgaXNGZXRjaGVyKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdCB8fCByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCB1bndyYXApIHtcbiAgaWYgKHVud3JhcCA9PT0gdm9pZCAwKSB7XG4gICAgdW53cmFwID0gZmFsc2U7XG4gIH1cbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh1bndyYXApIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLnVud3JhcHBlZERhdGFcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKHYgPT4gdiA9PT0gXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbikge1xuICBsZXQgc2VhcmNoID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKSkge1xuICAgIC8vIFJldHVybiB0aGUgbGVhZiBpbmRleCByb3V0ZSB3aGVuIGluZGV4IGlzIHByZXNlbnRcbiAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIE90aGVyd2lzZSBncmFiIHRoZSBkZWVwZXN0IFwicGF0aCBjb250cmlidXRpbmdcIiBtYXRjaCAoaWdub3JpbmcgaW5kZXggYW5kXG4gIC8vIHBhdGhsZXNzIGxheW91dCByb3V0ZXMpXG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXNbcGF0aE1hdGNoZXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obmF2aWdhdGlvbikge1xuICBsZXQge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZSxcbiAgICB0ZXh0LFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb25cbiAgfSA9IG5hdmlnYXRpb247XG4gIGlmICghZm9ybU1ldGhvZCB8fCAhZm9ybUFjdGlvbiB8fCAhZm9ybUVuY1R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZvcm1EYXRhICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSBlbHNlIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGxvY2F0aW9uLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICB9O1xuICByZXR1cm4gbmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGRhdGEpIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlcikge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gZ2V0RG9uZUZldGNoZXIoZGF0YSkge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICBkYXRhXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24sIElETEVfQkxPQ0tFUiwgSURMRV9GRVRDSEVSLCBJRExFX05BVklHQVRJT04sIFVOU0FGRV9ERUZFUlJFRF9TWU1CT0wsIERlZmVycmVkRGF0YSBhcyBVTlNBRkVfRGVmZXJyZWREYXRhLCBFcnJvclJlc3BvbnNlSW1wbCBhcyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIGFzIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyBhcyBVTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcywgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMgYXMgVU5TQUZFX2dldFBhdGhDb250cmlidXRpbmdNYXRjaGVzLCBpbnZhcmlhbnQgYXMgVU5TQUZFX2ludmFyaWFudCwgd2FybmluZyBhcyBVTlNBRkVfd2FybmluZywgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVNZW1vcnlIaXN0b3J5LCBjcmVhdGVQYXRoLCBjcmVhdGVSb3V0ZXIsIGNyZWF0ZVN0YXRpY0hhbmRsZXIsIGRlZmVyLCBnZW5lcmF0ZVBhdGgsIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IsIGdldFRvUGF0aG5hbWUsIGlzRGVmZXJyZWREYXRhLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwgam9pblBhdGhzLCBqc29uLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCBub3JtYWxpemVQYXRobmFtZSwgcGFyc2VQYXRoLCByZWRpcmVjdCwgcmVkaXJlY3REb2N1bWVudCwgcmVzb2x2ZVBhdGgsIHJlc29sdmVUbywgc3RyaXBCYXNlbmFtZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIkFjdGlvbiIsIlBvcFN0YXRlRXZlbnRUeXBlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIm9wdGlvbnMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsInY1Q29tcGF0IiwiZW50cmllcyIsIm1hcCIsImVudHJ5IiwiaW5kZXgiLCJjcmVhdGVNZW1vcnlMb2NhdGlvbiIsInN0YXRlIiwidW5kZWZpbmVkIiwiY2xhbXBJbmRleCIsImFjdGlvbiIsIlBvcCIsImxpc3RlbmVyIiwibiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJ0byIsImxvY2F0aW9uIiwiY3JlYXRlTG9jYXRpb24iLCJwYXRobmFtZSIsIndhcm5pbmciLCJjaGFyQXQiLCJKU09OIiwic3RyaW5naWZ5IiwiY3JlYXRlSHJlZiIsImNyZWF0ZVBhdGgiLCJoaXN0b3J5IiwiY3JlYXRlVVJMIiwiVVJMIiwiZW5jb2RlTG9jYXRpb24iLCJwYXRoIiwicGFyc2VQYXRoIiwic2VhcmNoIiwiaGFzaCIsInB1c2giLCJQdXNoIiwibmV4dExvY2F0aW9uIiwic3BsaWNlIiwiZGVsdGEiLCJyZXBsYWNlIiwiUmVwbGFjZSIsImdvIiwibmV4dEluZGV4IiwibGlzdGVuIiwiZm4iLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImNyZWF0ZUJyb3dzZXJMb2NhdGlvbiIsIndpbmRvdyIsImdsb2JhbEhpc3RvcnkiLCJ1c3IiLCJjcmVhdGVCcm93c2VySHJlZiIsImdldFVybEJhc2VkSGlzdG9yeSIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiY3JlYXRlSGFzaExvY2F0aW9uIiwic3Vic3RyIiwic3RhcnRzV2l0aCIsImNyZWF0ZUhhc2hIcmVmIiwiYmFzZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJ1cmwiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJ2YWxpZGF0ZUhhc2hMb2NhdGlvbiIsImludmFyaWFudCIsInZhbHVlIiwibWVzc2FnZSIsIkVycm9yIiwiY29uZCIsImNvbnNvbGUiLCJ3YXJuIiwiZSIsImNyZWF0ZUtleSIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0SGlzdG9yeVN0YXRlIiwiaWR4IiwiY3VycmVudCIsIl9yZWYiLCJwYXJzZWRQYXRoIiwic2VhcmNoSW5kZXgiLCJnZXRMb2NhdGlvbiIsInZhbGlkYXRlTG9jYXRpb24iLCJkZWZhdWx0VmlldyIsImdldEluZGV4IiwicmVwbGFjZVN0YXRlIiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJET01FeGNlcHRpb24iLCJuYW1lIiwib3JpZ2luIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZXN1bHRUeXBlIiwiaW1tdXRhYmxlUm91dGVLZXlzIiwiU2V0IiwiaXNJbmRleFJvdXRlIiwicm91dGUiLCJjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzIiwicm91dGVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsIm1hdGNoUm91dGVzIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsInN0cmlwQmFzZW5hbWUiLCJicmFuY2hlcyIsImZsYXR0ZW5Sb3V0ZXMiLCJyYW5rUm91dGVCcmFuY2hlcyIsIm1hdGNoZXMiLCJtYXRjaFJvdXRlQnJhbmNoIiwic2FmZWx5RGVjb2RlVVJJIiwiY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2giLCJtYXRjaCIsImxvYWRlckRhdGEiLCJwYXJhbXMiLCJkYXRhIiwiaGFuZGxlIiwicGFyZW50c01ldGEiLCJmbGF0dGVuUm91dGUiLCJyZWxhdGl2ZVBhdGgiLCJtZXRhIiwiY2FzZVNlbnNpdGl2ZSIsImNoaWxkcmVuSW5kZXgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiX3JvdXRlJHBhdGgiLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2hQYXRoIiwicGF0aG5hbWVCYXNlIiwibm9ybWFsaXplUGF0aG5hbWUiLCJnZW5lcmF0ZVBhdGgiLCJvcmlnaW5hbFBhdGgiLCJwcmVmaXgiLCJwIiwiU3RyaW5nIiwiYXJyYXkiLCJpc0xhc3RTZWdtZW50Iiwic3RhciIsImtleU1hdGNoIiwib3B0aW9uYWwiLCJwYXJhbSIsInBhdHRlcm4iLCJtYXRjaGVyIiwicGFyYW1OYW1lcyIsImNvbXBpbGVQYXRoIiwiY2FwdHVyZUdyb3VwcyIsIm1lbW8iLCJwYXJhbU5hbWUiLCJzcGxhdFZhbHVlIiwic2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50IiwicmVnZXhwU291cmNlIiwiXyIsIlJlZ0V4cCIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsInRvTG93ZXJDYXNlIiwic3RhcnRJbmRleCIsIm5leHRDaGFyIiwicmVzb2x2ZVBhdGgiLCJmcm9tUGF0aG5hbWUiLCJ0b1BhdGhuYW1lIiwicmVzb2x2ZVBhdGhuYW1lIiwibm9ybWFsaXplU2VhcmNoIiwibm9ybWFsaXplSGFzaCIsInJlbGF0aXZlU2VnbWVudHMiLCJwb3AiLCJnZXRJbnZhbGlkUGF0aEVycm9yIiwiY2hhciIsImZpZWxkIiwiZGVzdCIsImdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwicmVzb2x2ZVRvIiwidG9BcmciLCJyb3V0ZVBhdGhuYW1lcyIsImxvY2F0aW9uUGF0aG5hbWUiLCJpc1BhdGhSZWxhdGl2ZSIsImlzRW1wdHlQYXRoIiwiZnJvbSIsInJvdXRlUGF0aG5hbWVJbmRleCIsInRvU2VnbWVudHMiLCJzaGlmdCIsImhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCIsImhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoIiwiZ2V0VG9QYXRobmFtZSIsInBhdGhzIiwianNvbiIsImluaXQiLCJyZXNwb25zZUluaXQiLCJzdGF0dXMiLCJoZWFkZXJzIiwiSGVhZGVycyIsImhhcyIsInNldCIsIlJlc3BvbnNlIiwiQWJvcnRlZERlZmVycmVkRXJyb3IiLCJEZWZlcnJlZERhdGEiLCJjb25zdHJ1Y3RvciIsInBlbmRpbmdLZXlzU2V0Iiwic3Vic2NyaWJlcnMiLCJkZWZlcnJlZEtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJyZWplY3QiLCJhYm9ydFByb21pc2UiLCJQcm9taXNlIiwiciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJvbkFib3J0IiwidW5saXN0ZW5BYm9ydFNpZ25hbCIsInNpZ25hbCIsImFjYyIsInRyYWNrUHJvbWlzZSIsImRvbmUiLCJhZGQiLCJwcm9taXNlIiwicmFjZSIsInRoZW4iLCJvblNldHRsZSIsImNhdGNoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhYm9ydGVkIiwiZGVsZXRlIiwidW5kZWZpbmVkRXJyb3IiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsInYiLCJrIiwicmVzb2x2ZURhdGEiLCJyZXNvbHZlIiwic2l6ZSIsInVud3JhcHBlZERhdGEiLCJfcmVmMiIsInVud3JhcFRyYWNrZWRQcm9taXNlIiwicGVuZGluZ0tleXMiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVzcG9uc2UiLCJFcnJvclJlc3BvbnNlSW1wbCIsInN0YXR1c1RleHQiLCJpbnRlcm5hbCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwidmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIiLCJ2YWxpZE11dGF0aW9uTWV0aG9kcyIsInZhbGlkUmVxdWVzdE1ldGhvZHNBcnIiLCJ2YWxpZFJlcXVlc3RNZXRob2RzIiwicmVkaXJlY3RTdGF0dXNDb2RlcyIsInJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyIsIklETEVfTkFWSUdBVElPTiIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsInRleHQiLCJJRExFX0ZFVENIRVIiLCJJRExFX0JMT0NLRVIiLCJwcm9jZWVkIiwicmVzZXQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzIiwiaGFzRXJyb3JCb3VuZGFyeSIsIkJvb2xlYW4iLCJjcmVhdGVSb3V0ZXIiLCJyb3V0ZXJXaW5kb3ciLCJpc0Jyb3dzZXIiLCJjcmVhdGVFbGVtZW50IiwiaXNTZXJ2ZXIiLCJkZXRlY3RFcnJvckJvdW5kYXJ5IiwiZGF0YVJvdXRlcyIsImluRmxpZ2h0RGF0YVJvdXRlcyIsImZ1dHVyZSIsInY3X25vcm1hbGl6ZUZvcm1NZXRob2QiLCJ2N19wcmVwZW5kQmFzZW5hbWUiLCJ1bmxpc3Rlbkhpc3RvcnkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsImdldFNjcm9sbFJlc3RvcmF0aW9uS2V5IiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJpbml0aWFsU2Nyb2xsUmVzdG9yZWQiLCJoeWRyYXRpb25EYXRhIiwiaW5pdGlhbE1hdGNoZXMiLCJpbml0aWFsRXJyb3JzIiwiZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvciIsImdldFNob3J0Q2lyY3VpdE1hdGNoZXMiLCJpbml0aWFsaXplZCIsIm0iLCJsYXp5IiwibG9hZGVyIiwicm91dGVyIiwiaGlzdG9yeUFjdGlvbiIsIm5hdmlnYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJhY3Rpb25EYXRhIiwiZXJyb3JzIiwiZmV0Y2hlcnMiLCJNYXAiLCJibG9ja2VycyIsInBlbmRpbmdBY3Rpb24iLCJwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0IiwicGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIiwiaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwiaXNSZXZhbGlkYXRpb25SZXF1aXJlZCIsImNhbmNlbGxlZERlZmVycmVkUm91dGVzIiwiY2FuY2VsbGVkRmV0Y2hlckxvYWRzIiwiZmV0Y2hDb250cm9sbGVycyIsImluY3JlbWVudGluZ0xvYWRJZCIsInBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkIiwiZmV0Y2hSZWxvYWRJZHMiLCJmZXRjaFJlZGlyZWN0SWRzIiwiZmV0Y2hMb2FkTWF0Y2hlcyIsImFjdGl2ZURlZmVycmVkcyIsImJsb2NrZXJGdW5jdGlvbnMiLCJpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSIsImluaXRpYWxpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwidXBkYXRlQmxvY2tlciIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwiZGlzcG9zZSIsImNsZWFyIiwiZGVsZXRlRmV0Y2hlciIsImRlbGV0ZUJsb2NrZXIiLCJuZXdTdGF0ZSIsImNvbXBsZXRlTmF2aWdhdGlvbiIsIl9sb2NhdGlvbiRzdGF0ZSIsIl9sb2NhdGlvbiRzdGF0ZTIiLCJpc0FjdGlvblJlbG9hZCIsImlzTXV0YXRpb25NZXRob2QiLCJfaXNSZWRpcmVjdCIsImtleXMiLCJtZXJnZUxvYWRlckRhdGEiLCJnZXRTYXZlZFNjcm9sbFBvc2l0aW9uIiwibmF2aWdhdGUiLCJvcHRzIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVUbyIsImZyb21Sb3V0ZUlkIiwicmVsYXRpdmUiLCJzdWJtaXNzaW9uIiwibm9ybWFsaXplTmF2aWdhdGVPcHRpb25zIiwidXNlclJlcGxhY2UiLCJwZW5kaW5nRXJyb3IiLCJyZXZhbGlkYXRlIiwiaW50ZXJydXB0QWN0aXZlTG9hZHMiLCJzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJvdmVycmlkZU5hdmlnYXRpb24iLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJyb3V0ZXNUb1VzZSIsImxvYWRpbmdOYXZpZ2F0aW9uIiwibm90Rm91bmRNYXRjaGVzIiwiY2FuY2VsQWN0aXZlRGVmZXJyZWRzIiwiaXNIYXNoQ2hhbmdlT25seSIsInJlcXVlc3QiLCJjcmVhdGVDbGllbnRTaWRlUmVxdWVzdCIsInBlbmRpbmdBY3Rpb25EYXRhIiwiZmluZE5lYXJlc3RCb3VuZGFyeSIsImFjdGlvbk91dHB1dCIsImhhbmRsZUFjdGlvbiIsInNob3J0Q2lyY3VpdGVkIiwicGVuZGluZ0FjdGlvbkVycm9yIiwiZ2V0TG9hZGluZ05hdmlnYXRpb24iLCJSZXF1ZXN0IiwiaGFuZGxlTG9hZGVycyIsImZldGNoZXJTdWJtaXNzaW9uIiwiZ2V0U3VibWl0dGluZ05hdmlnYXRpb24iLCJhY3Rpb25NYXRjaCIsImdldFRhcmdldE1hdGNoIiwidHlwZSIsIm1ldGhvZCIsInJvdXRlSWQiLCJjYWxsTG9hZGVyT3JBY3Rpb24iLCJpc1JlZGlyZWN0UmVzdWx0Iiwic3RhcnRSZWRpcmVjdE5hdmlnYXRpb24iLCJpc0Vycm9yUmVzdWx0IiwiYm91bmRhcnlNYXRjaCIsImlzRGVmZXJyZWRSZXN1bHQiLCJhY3RpdmVTdWJtaXNzaW9uIiwiZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uIiwibWF0Y2hlc1RvTG9hZCIsInJldmFsaWRhdGluZ0ZldGNoZXJzIiwiZ2V0TWF0Y2hlc1RvTG9hZCIsInVwZGF0ZWRGZXRjaGVycyIsIm1hcmtGZXRjaFJlZGlyZWN0c0RvbmUiLCJyZiIsImZldGNoZXIiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwiZ2V0TG9hZGluZ0ZldGNoZXIiLCJhYm9ydEZldGNoZXIiLCJhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMiLCJmIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsImZldGNoZXJLZXkiLCJwcm9jZXNzTG9hZGVyRGF0YSIsImRlZmVycmVkRGF0YSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwic2hvdWxkVXBkYXRlRmV0Y2hlcnMiLCJnZXRGZXRjaGVyIiwiZmV0Y2giLCJzZXRGZXRjaGVyRXJyb3IiLCJoYW5kbGVGZXRjaGVyQWN0aW9uIiwiaGFuZGxlRmV0Y2hlckxvYWRlciIsInJlcXVlc3RNYXRjaGVzIiwiZXhpc3RpbmdGZXRjaGVyIiwiZ2V0U3VibWl0dGluZ0ZldGNoZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJmZXRjaFJlcXVlc3QiLCJvcmlnaW5hdGluZ0xvYWRJZCIsImFjdGlvblJlc3VsdCIsImRvbmVGZXRjaGVyIiwiZ2V0RG9uZUZldGNoZXIiLCJsb2FkaW5nRmV0Y2hlciIsInJldmFsaWRhdGlvblJlcXVlc3QiLCJsb2FkSWQiLCJsb2FkRmV0Y2hlciIsInN0YWxlS2V5IiwicmVzb2x2ZURlZmVycmVkRGF0YSIsIl90ZW1wIiwicmVkaXJlY3RMb2NhdGlvbiIsImlzRG9jdW1lbnRSZWxvYWQiLCJyZWxvYWREb2N1bWVudCIsInJlZGlyZWN0SGlzdG9yeUFjdGlvbiIsImN1cnJlbnRNYXRjaGVzIiwiZmV0Y2hlcnNUb0xvYWQiLCJhbGwiLCJyZXNvbHZlRGVmZXJyZWRSZXN1bHRzIiwibWFya0ZldGNoZXJzRG9uZSIsImRvbmVLZXlzIiwibGFuZGVkSWQiLCJ5ZWV0ZWRLZXlzIiwiZ2V0QmxvY2tlciIsImJsb2NrZXIiLCJuZXdCbG9ja2VyIiwiYmxvY2tlckZ1bmN0aW9uIiwicHJlZGljYXRlIiwiY2FuY2VsbGVkUm91dGVJZHMiLCJkZmQiLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uIiwiZ2V0S2V5IiwieSIsImdldFNjcm9sbEtleSIsIl9pbnRlcm5hbFNldFJvdXRlcyIsIm5ld1JvdXRlcyIsIl9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMiLCJfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHMiLCJVTlNBRkVfREVGRVJSRURfU1lNQk9MIiwiU3ltYm9sIiwiY3JlYXRlU3RhdGljSGFuZGxlciIsInF1ZXJ5IiwiX3RlbXAyIiwicmVxdWVzdENvbnRleHQiLCJpc1ZhbGlkTWV0aG9kIiwibWV0aG9kTm90QWxsb3dlZE1hdGNoZXMiLCJzdGF0dXNDb2RlIiwibG9hZGVySGVhZGVycyIsImFjdGlvbkhlYWRlcnMiLCJxdWVyeUltcGwiLCJpc1Jlc3BvbnNlIiwicXVlcnlSb3V0ZSIsIl90ZW1wMyIsImZpbmQiLCJ2YWx1ZXMiLCJfcmVzdWx0JGFjdGl2ZURlZmVycmUiLCJyb3V0ZU1hdGNoIiwic3VibWl0IiwibG9hZFJvdXRlRGF0YSIsImlzUXVlcnlSb3V0ZVJlc3BvbnNlIiwiaXNSZWRpcmVjdFJlc3BvbnNlIiwiaXNSb3V0ZVJlcXVlc3QiLCJpc1N0YXRpY1JlcXVlc3QiLCJMb2NhdGlvbiIsImNvbnRleHQiLCJsb2FkZXJSZXF1ZXN0IiwiZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkiLCJwcm9jZXNzUm91dGVMb2FkZXJEYXRhIiwiZXhlY3V0ZWRMb2FkZXJzIiwiZnJvbUVudHJpZXMiLCJnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yIiwibmV3Q29udGV4dCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaXNTdWJtaXNzaW9uTmF2aWdhdGlvbiIsImJvZHkiLCJwcmVwZW5kQmFzZW5hbWUiLCJjb250ZXh0dWFsTWF0Y2hlcyIsImFjdGl2ZVJvdXRlTWF0Y2giLCJoYXNOYWtlZEluZGV4UXVlcnkiLCJub3JtYWxpemVGb3JtTWV0aG9kIiwiaXNGZXRjaGVyIiwiZ2V0SW52YWxpZEJvZHlFcnJvciIsInJhd0Zvcm1NZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInN0cmlwSGFzaEZyb21QYXRoIiwiRm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJfcmVmMyIsInBhcnNlIiwic2VhcmNoUGFyYW1zIiwiY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMiLCJjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YSIsImFwcGVuZCIsImJvdW5kYXJ5SWQiLCJib3VuZGFyeU1hdGNoZXMiLCJmaW5kSW5kZXgiLCJjdXJyZW50VXJsIiwibmV4dFVybCIsIm5hdmlnYXRpb25NYXRjaGVzIiwiaXNOZXdMb2FkZXIiLCJjdXJyZW50Um91dGVNYXRjaCIsIm5leHRSb3V0ZU1hdGNoIiwic2hvdWxkUmV2YWxpZGF0ZUxvYWRlciIsImN1cnJlbnRQYXJhbXMiLCJuZXh0UGFyYW1zIiwiZGVmYXVsdFNob3VsZFJldmFsaWRhdGUiLCJpc05ld1JvdXRlSW5zdGFuY2UiLCJmZXRjaGVyTWF0Y2hlcyIsImZldGNoZXJNYXRjaCIsInNob3VsZFJldmFsaWRhdGUiLCJjdXJyZW50TG9hZGVyRGF0YSIsImN1cnJlbnRNYXRjaCIsImlzTmV3IiwiaXNNaXNzaW5nRGF0YSIsImN1cnJlbnRQYXRoIiwibG9hZGVyTWF0Y2giLCJhcmciLCJyb3V0ZUNob2ljZSIsImxvYWRMYXp5Um91dGVNb2R1bGUiLCJsYXp5Um91dGUiLCJyb3V0ZVRvVXBkYXRlIiwicm91dGVVcGRhdGVzIiwibGF6eVJvdXRlUHJvcGVydHkiLCJzdGF0aWNSb3V0ZVZhbHVlIiwiaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkIiwicmVzdWx0VHlwZSIsIm9uUmVqZWN0IiwicnVuSGFuZGxlciIsImhhbmRsZXIiLCJoYW5kbGVyRXJyb3IiLCJwcm90b2NvbCIsImlzU2FtZUJhc2VuYW1lIiwicXVlcnlSb3V0ZVJlc3BvbnNlIiwiY29udGVudFR5cGUiLCJpc0RlZmVycmVkRGF0YSIsIl9yZXN1bHQkaW5pdCIsIl9yZXN1bHQkaW5pdDIiLCJkZWZlcnJlZCIsImZvdW5kRXJyb3IiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VkTG9hZGVyRGF0YSIsImVsaWdpYmxlTWF0Y2hlcyIsInJldmVyc2UiLCJfdGVtcDQiLCJlcnJvck1lc3NhZ2UiLCJvYmoiLCJzaWduYWxzIiwiaXNSZXZhbGlkYXRpbmdMb2FkZXIiLCJ1bndyYXAiLCJnZXRBbGwiLCJwYXRoTWF0Y2hlcyIsIlVOU0FGRV9EZWZlcnJlZERhdGEiLCJVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwiLCJVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2giLCJVTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsIlVOU0FGRV9nZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyIsIlVOU0FGRV9pbnZhcmlhbnQiLCJVTlNBRkVfd2FybmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@remix-run/router/dist/router.js\n");

/***/ })

};
;